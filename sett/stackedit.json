{"author.name":"","file.4eyl0ICaPfL3V9NIDKXYomw4.content":"\n\n| Michał Fudała                   |                             |             24.03.2015              |\n ----------------- | ---------------------------- | ------------------\n| Metody Obliczeniowe w Nauce i Technice |             |  |\n| Laboratorium 3: **Alebra liniowa**          |             |  |\n\n\n\n\n\n\n# <center> Sprawozdanie </center>\n\n\n\n\n### 1. Wstęp\n\nCelem ćwiczenia było napisanie programu rozwiązującego układ równań metodą LU oraz zbadanie czasu wykonania tego programu w zależności od wielkości macierzy ( N ). Zostały zbadane również czasy wykonania `gsl_linalg_solve_tridiag` dla macierzy trójdiagonalnych w zależności od N. \nOstatnia część ćwiczenia polegała na zbadaniu działania oraz szybkości ( w zależności od N ) różnych funkcji BLAS ( Basic Linear Algebra Subprograms ) dla różnych poziomów.\n\nThe BLAS  are routines that provide standard building blocks for performing basic vector and matrix operations\n\n### 2. Wykonanie ćwiczenia\n\nPorównanie czasu metod:\n\n* dekompozycja LU \n* `gsl_linal_solv_tridiag`\n\n\nDo wyznaczania macierzy U i L został wykorzystany algorytm Doolittle'a.\n\nWzory ogólne na poszczególne elementy macierzy rozkładu przedstawiają się następująco:\n\n$$ u_{ij} = a_{ij} - \\sum_{k=1}^{i-1}  l_{ij}u_{kj} \\ dla \\ j\\in \\{i, i+1, \\dots, n\\}$$\n\n$$ l_{ij} = \\frac{1}{u_{ij}} ( a_{ji} - \\sum_{k=1}^{i-1}  l_{jk}u_{ki}) \\ dla \\ j\\in \\{i+1, i+1, \\dots, n\\}$$\n\nWyznaczanie wektora pomocniczego zostało zrealizowane według zależności:\n\n$$ y_i = v_i - \\sum_{j=0}^{i - 1}l_{ij}y_j \\ dla \\ i\\in\\{0,1,...,n-1\\}$$\n\nWyznaczanie wektora wynikowego zostało zrealizowane według zależności:\n\n$$ x_i = \\frac{1}{u_{ij}}(y_i - \\sum_{j = i +1}^{n-1} u_{ij}x_j ) \\ dla \\ i \\in \\{0,1,...,n-1\\} $$\n\nWażnym faktem, istotnym do zauważenia jest to, iż w przypadku wyznaczania y i iterujemy od $0$ do $n-1$, natomiast w przypadku $x$ i przeciwnie, od $n-1$ do $0$.\n\nKod implementacji rozwiązywania układu równań metodą LU:\n\n\n```c\n// lu decompose\nint ludist(int n, gsl_matrix * A) {\n    int i,j,k;\n\n    for(k = 0; k < n - 1; k++) {\n        if(fabs(gsl_matrix_get(A, k, k)) < eps) return 0;\n        double temp;\n        for(i = k + 1; i < n; i++) {\n            temp = gsl_matrix_get(A, i, k);\n            gsl_matrix_set(A, i, k, temp / gsl_matrix_get(A, k, k));\n        }\n\n        for(i = k + 1; i < n; i++) {\n            for(j = k + 1; j < n; j++) {\n                temp = gsl_matrix_get(A, i, j);\n                gsl_matrix_set(A, i, j,temp - gsl_matrix_get(A, i, k) * gsl_matrix_get(A, k, j));\n            }\n        }\n    }\n  \n    return 1;\n}\n\n// lu solve\nint lusolve(int n, gsl_matrix* A, gsl_vector * B, gsl_vector * X) {\n    int    i,j;\n    double s;\n\n    gsl_vector_set(X, 0, gsl_vector_get(B, 0));\n\n    for(i = 1; i < n; i++) {\n        s = 0;\n        for(j = 0; j < i; j++) {\n            s += gsl_matrix_get(A, i, j) * gsl_vector_get(X, j);\n        }\n        gsl_vector_set(X, i, gsl_vector_get(B, i) - s);\n    }\n\n    if(fabs(gsl_matrix_get(A, n - 1, n - 1)) < eps) return 0;\n\n    gsl_vector_set(X, n - 1, gsl_vector_get(X, n - 1) / gsl_matrix_get(A, n -1, n -1));\n\n    for(i = n - 2; i >= 0; i--) {\n        s = 0;\n        for(j = i + 1; j < n; j++) s += gsl_matrix_get(A, i, j) * gsl_vector_get(X, j);\n        if(fabs(gsl_matrix_get(A, i, i)) < eps) return 0;\n        gsl_vector_set(X, i, (gsl_vector_get(X, i) - s) / gsl_matrix_get(A, i, i));\n    }\n\n    return 1;\n}\n\n```\n\n\nWykres czasu w zależności od różnej ilości danych ( dla LU oraz dla LU z macierzą trójdiagonalną ):\n<center>![](http://student.agh.edu.pl/~mfudala/omg/lu_lu_tri.svg) </center>\n\n\nKod wykorzystania `gsl_linalg_solve_tridiag`:\n```c\nint gsl_tri_solve(int N) {\n    gsl_vector* vec1 = gen_vector(rand1d, N - 1, 0.0, 1000.0);\n    gsl_vector* vec2 = gen_vector(rand1d, N, 0.0, 1000.0);\n    gsl_vector* vec3 = gen_vector(rand1d, N - 1, 0.0, 1000.0);\n    gsl_vector* b = gen_vector(rand1d, N, 0.0, 1000.0);\n\n    gsl_vector* x = gsl_vector_alloc(N);\n\n    gsl_linalg_solve_tridiag(vec2, vec1, vec3, b, x);\n\n    gsl_vector_free(vec1);\n    gsl_vector_free(vec2);\n    gsl_vector_free(vec3);\n    gsl_vector_free(b);\n    gsl_vector_free(x);\n    return 1;\n}\n```\n\n\nWykres w zależności od danych dla funkcji `gsl_linalg_solve_tridiag`\n\n<center> ![](http://student.agh.edu.pl/~mfudala/omg/gsl.svg) </center>\n\n\nPorównanie metody `gsl_linalg_solve_tridiag` z implementacją LU:\n\n<center> ![](http://student.agh.edu.pl/~mfudala/omg/lu_gsl.svg) </center>\n\n\n\n\n\n\n---\n\nPorównanie czasu metod:\n\n* dekompozycja LU dla macierzy trójdiagonalnej\n* `gsl_linal_solv_tridiag`\n\n---\n\n\nKod wykorzystania BLASów:\n\n**Level 1:**\n```c\nnt blas_l1(int N) {\n    gsl_vector* vec1 = gen_vector(rand1d, N, 0.0, 1000.0);\n    gsl_vector* vec2 = gen_vector(rand1d, N, 0.0, 1000.0);\n    double res;\n\n    gsl_blas_ddot(vec1, vec2, &res);\n\n    gsl_vector_free(vec1);\n    gsl_vector_free(vec2);\n    return 1;\n}\n```\n\n\n**Level 2**\n\n```c\nint blas_l2(int N) {\n    double alpha_random = rand1d(0.0);\n    double beta_random = rand1d(0.0);\n    gsl_matrix* A = gen_matrix(rand2d, N, 0.0, 1000.0);\n    gsl_vector* x = gen_vector(rand1d, N, 0.0, 1000.0);\n    gsl_vector* y = gen_vector(rand1d, N, 0.0, 1000.0);\n\n    gsl_blas_dgemv(CblasNoTrans, alpha_random, A, x, beta_random, y);\n\n    gsl_vector_free(x);\n    gsl_vector_free(y);\n    gsl_matrix_free(A);\n    return 1;\n}\n```\n\n\n**Level 3**\n\n```c\nint blas_l3(int N) {\n    double alpha_random = rand1d(0.0);\n    double beta_random = rand1d(0.0);\n    gsl_matrix* A = gen_matrix(rand2d, N, 0.0, 1000.0);\n    gsl_matrix* B = gen_matrix(rand2d, N, 0.0, 1000.0);\n    gsl_matrix* C = gen_matrix(rand2d, N, 0.0, 1000.0);\n\n    gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, alpha_random, A, B, beta_random, C);\n\n    gsl_matrix_free(A);\n    gsl_matrix_free(B);\n    gsl_matrix_free(C);\n    return 1;\n}\n```\n\n\nPorównanie czasu dla różnych poziomów BLAS dla metody:\n\n* 1 ( `gsl_blas_ddot` )\n* 2 ( `gsl_blas_dgemv` )\n* 3 ( `gsl_blas_dgemm` )\n\n\nWykres z dużym \"step'em\" dla `gsl_blas_dgemv` ( poziom 2)\n<center> ![](http://student.agh.edu.pl/~mfudala/omg/blas_sparse.svg) </center>\n\nPorównanie poszczególnych BLASów:\n<center> ![Level1](http://student.agh.edu.pl/~mfudala/omg/blas.svg) </center>\n\n\n","file.4eyl0ICaPfL3V9NIDKXYomw4.editorEnd":"6142","file.4eyl0ICaPfL3V9NIDKXYomw4.editorScrollTop":"8466","file.4eyl0ICaPfL3V9NIDKXYomw4.editorStart":"6142","file.4eyl0ICaPfL3V9NIDKXYomw4.previewScrollTop":"7003","file.4eyl0ICaPfL3V9NIDKXYomw4.publish":";","file.4eyl0ICaPfL3V9NIDKXYomw4.selectTime":"1427845369273","file.4eyl0ICaPfL3V9NIDKXYomw4.sync":";sync.gdrive.0B0eCVEhOzw7BTV84dUczVlVudzg;","file.4eyl0ICaPfL3V9NIDKXYomw4.title":"Sprawozdanie mownit lab3","file.6EG4REUWBttCZnGypC5cGz80.content":"<center> Sprawozdanie </center>\n----\n\n\n<center> ![tabelka](http://i.imgur.com/icRC7xw.png) </center>\n\n\n### 1. Wstęp \n\nCelem ćwiczenia było poznanie możliwości 8-bitowych mikrokontrolerów o architekturze RISC oraz technik programowania tych mikrokontrolerów w językach wysokiego poziomu na przykładzie języka C.\n\n### 2. Wykonanie ćwiczenia\n\n\n\nPo zapoznaniu się z interfejsem programu AVR Studio 4 i skonfigurowaniem go, przeszliśmy do realizacji poszczególnych zadań.\n\n---\nNagłowek każdego z plików:\n\n```c\n#ifndef F_CPU\n#define F_CPU 16000000 //okreslenie czestotliwosci pracy mikrokontrolera\n#endif\n#include <avr/io.h>\n#include <util/delay.h>\n```\n\n\nFunkcje wykorzystywane we wszystkich następnych ćwiczeniach:\n```c\nvoid wait10(int delay) {\n\tint i;\n\tfor(i = 0; delay > i; i++) \n\t\t_delay_ms(10);\n}\n\nvoid set_porta_and_wait(char porta, char delay) {\n\tPORTA = porta;\n\t_delay_ms(delay);\n}\n```\n\n---\n\n####**a) Kod realizujący efekt wędrującego światła**:\n\n```c\n#define DELAY 25\n\nint main(void) {\n    DDRA = 0x0F; \n    PORTA = 0b00000001;\n    char temp = 0b00000001;\n    do {\n        for(int j = 0; 4 > j; j++) {\n\t        wait10(DELAY);\n            temp <<= 1;\n            PORTA = ~temp;\n        }\n        for(int j = 0; 4 > j; j++) {\n            wait10(DELAY);\n            temp >>= 1;\n            PORTA = ~temp;\n        }         \n    } while(1);\n    return 0;\n}\n```\n\n---\n\n####**b) Silnik krokowy - sterowanie jednofazowe**:\n\n$ A, B, C, D $ - uzwojenie silnika\n\nSekwencja napięć:\n$ A \\rightarrow B \\rightarrow C \\rightarrow D $\n\nKod:\n\n```c\n#define DELAY 10\nvoid jednofazowe() {\n    DDRA =  0b11111111;\n    set_porta_and_wait(0b11111111, 30);\n    do {\n        set_porta_and_wait(0b11100000, DELAY);\n        set_porta_and_wait(0b11010000, DELAY);\n        set_porta_and_wait(0b10110000, DELAY);\n        set_porta_and_wait(0b01110000, DELAY);\n    } while(1);\n}\n```\n\n\n####**c) Silnik krokowy - sterowanie dwufazowe**:\n\n\n$ A, B, C, D $ - uzwojenie silnika\n\nSekwencja napięć:\n$ AB \\rightarrow BC \\rightarrow CD \\rightarrow DA $\n\nKod:\n\n```c\n#define DELAY 10\nvoid dwufazowe() {\n    DDRA =  0b11111111;\n    set_porta_and_wait(0b11111111, 30);\n    do {    \n        set_porta_and_wait(0b00110000, DELAY);\n        set_porta_and_wait(0b10010000, DELAY);\n        set_porta_and_wait(0b11000000, DELAY);\n        set_porta_and_wait(0b01100000, DELAY);\n    } while(1);\n}\n```\n\n####**d) Silnik krokowy - sterowanie półkrokowe**:\n\n$ A, B, C, D $ - uzwojenie silnika\n\nSekwencja napięć:\n\n$ A \\rightarrow AB \\rightarrow B \\rightarrow BC \\rightarrow C \\rightarrow CD \\rightarrow D\\rightarrow DA \\rightarrow A $\n\nKod:\n\n```c\n#define DELAY 10\nvoid polkrokowe_prawo() {\n    DDRA = 0b11111111;\n    set_porta_and_wait(0b11111111, 30);\n    do {    \n        set_porta_and_wait(0b01110000, DELAY);\n        set_porta_and_wait(0b00110000, DELAY);\n        set_porta_and_wait(0b10110000, DELAY);\n        set_porta_and_wait(0b10010000, DELAY);\n        set_porta_and_wait(0b11010000, DELAY);\n        set_porta_and_wait(0b11000000, DELAY);\n        set_porta_and_wait(0b11100000, DELAY);\n        set_porta_and_wait(0b01100000, DELAY);\n    } while(1);\n}\n```\n```c\n#define DELAY 10\nvoid polkrokowe_lewo() {\n    DDRA=0b11111111;\n    set_porta_and_wait(0b11111111, 30);\n    do {\n        set_porta_and_wait(0b01100000, DELAY);\n        set_porta_and_wait(0b11100000, DELAY);\n        set_porta_and_wait(0b11000000, DELAY);\n        set_porta_and_wait(0b11010000, DELAY);\n        set_porta_and_wait(0b10010000, DELAY);\n        set_porta_and_wait(0b10110000, DELAY);\n        set_porta_and_wait(0b00110000, DELAY);\n        set_porta_and_wait(0b01110000, DELAY);\n    } while(1);\n}\n```\n\n---\n\nZbadane oraz zapisane zostały krytyczne wartości opóźnień dla, których praca poszczególnych silników zaczyna być niestabilna.\n\n###**Jednofazowy**\n| Kierunek               | Opóźnienie                            |             Działanie            |\n ----------------- | ---------------------------- | ------------------\n| w prawo |  5 ms | Stabilnie |\n| w prawo        |      4 ms        | Niestabilnie |\n| w prawo        |      2 ms        | Nie działa |\n| w lewo |  5 ms | Stabilnie |\n|  w lewo       |      4 ms        | Niestabilnie |\n|  w lewo       |      2 ms        | Nie działa |\n\n###**Dwufazowy**\n| Kierunek               | Opóźnienie                            |             Działanie            |\n ----------------- | ---------------------------- | ------------------\n| w prawo |  4 ms | Stabilnie |\n| w prawo        |      3 ms        | Stabilnie |\n| w prawo        |      2 ms        | Niestabilnie |\n| w prawo        |      1 ms        | Nie działa |\n| w lewo |  4 ms | Stabilnie |\n|  w lewo       |      3 ms        | Niestabilnie |\n|  w lewo       |      2 ms        | Niestabilnie |\n|  w lewo       |      1 ms        | Nie działa |\n\n\n###**Półkrokowy**\n\n| Kierunek               | Opóźnienie                            |             Działanie            |\n ----------------- | ---------------------------- | ------------------\n| w prawo |  2 ms | Stabilnie |\n| w prawo        |      1 ms        | Nie działa |\n| w lewo |  2 ms | Stabilnie |\n|  w lewo       |      1 ms        | Nie działa |\n\n\n--- \n\n\n####**e) Przycisk**:\n\nCelem tego ćwiczenia było napisanie kodu obsługującego naciśnięcie przycisku i zaświecenie diody na płytce mikrokontrolera.\n\nKod:\n\n```c\n\nvoid przycisk() {\n\tDDRA |= (1<<PA0); // konfiguracja PA0 jako wyjscia\n\tPORTA |=(1<<PA0); // wygaszenie LED\n\tDDRD &= ~(1<<PD2); // konfiguracja PD2 jako wejscie\n\tPORTD |=(1<<PD2); // ustawienie rezystora podciagajacego\n\tDDRD &= ~(1<<PD3); \n\tPORTD |=(1<<PD3); \n\twhile(1) { // nieskonczona petla \n\t\tif ( (PIND & (1<<PD2)) == 0 ) {\n\t\t\tPORTA=0b00000111; // zapalamy diode sterowana PA0\n\t\t}\n\t\telse if( (PIND & (1<<PD3)) == 0 ) {\n\t\t\tPORTA &= ~(1<<PA0);\n\t\t}\n\t}\n}\n```\n\n####**f) Przycisk - przerwania**:\n\nKod realizujący analogiczną funkcje jak poprzedni z tym, że przy wykorzystaniu mechanizmu przerwań:\n\n``` \n#ifndef F_CPU\n#define F_CPU 16000000 // 16 MHz - turn on external resonator (fuse bits)\n#endif\n#include <avr/io.h>\n#include <avr/interrupt.h>\nint main(void) {\n\tDDRA |= (1<<PA0); //konfiguracja PA0 jako wyjścia\n\tPORTA=0x01; // wygaszenie LED\n\tDDRD &= ~(1<<PD2); //konfiguracja portu D2 (INT0) jako wejście\n\tPORTD |= 1<<PD2; //ustawienie rezystora podciągającego – wymusza 1\n\tMCUCR |= 1<<ISC01; //konfiguracja przerwania INT0 – zbocze opadajace\n\tGICR |= 1<<INT0; //włączenie przerwania INT0\n\tsei(); //globalne włączenie przerwań\n\twhile(1) {}\n}\n//Procedura obsługi przerwania od wejścia INT0\nISR(INT0_vect) {\n\tPORTA &= ~(1<<PA0); // zapalamy diodę dolaczana do PA0\n}\n```\n\n---\n\n####**g) LCD**:\n\nW przypadku ekranu LCD udało nam się napisać kod, którego przez brak czasu nie udało się poprawnie uruchomić, prawdopodobnie przez złe skonfigurowanie przez nas sprzętu lub samej biblioteki do LCD.\n\nKod miał wypisywać tekst \"żółwik\" na ekranie LCD.\n\nKod:\n\n```c\nuint8_t zz[] = {0b0010, 0, 0b1111, 0b0001, 0b0110, 0b1000, 0b1111, 0};\nuint8_t uu[] = {0b0010, 0b0100, 0, 0b0110, 0b1001, 0b1001, 0b0110, 0};\n\nint main(void) {\n\tchar temp, i;\n\tLCD_Initialize();\n\tLCD_ProgrammChar(0, zz);\n\tLCD_ProgrammChar(1, uu);\n\t\n\tLCD_GoTo(0,0);\n\tLCD_WriteData(0); // “ż”\n\tLCD_WriteData(1); // “ó”\n\tLCD_WriteText(\"lwik\"); // “lwik”\n\t\n\t\n\tdo { } while(1);\n\t\n\treturn 0;\n}\n```\n\n\n","file.6EG4REUWBttCZnGypC5cGz80.editorEnd":"90","file.6EG4REUWBttCZnGypC5cGz80.editorScrollTop":"0","file.6EG4REUWBttCZnGypC5cGz80.editorStart":"90","file.6EG4REUWBttCZnGypC5cGz80.previewScrollTop":"60","file.6EG4REUWBttCZnGypC5cGz80.publish":";","file.6EG4REUWBttCZnGypC5cGz80.selectTime":"1427818248803","file.6EG4REUWBttCZnGypC5cGz80.sync":";sync.gdrive.0B0eCVEhOzw7BUGxSdkRucVBQT00;","file.6EG4REUWBttCZnGypC5cGz80.title":"Sprawozdanie mikro","file.7gFUaijL2e4jUQwl9s4mx3eI.content":"**Mikrooperacje**\n\nProjekt prostego komputera\n\nZainalabedin Navabi Digital Design and Implement....\n\nProgram Sequencing Datapath\n\nArithmetic-Logical Instructions Data-path\n\nDatapath for the Data-Transfer Instructions\n\nController Truth Table\n\n$$ \\int f(x) dx = x $$","file.7gFUaijL2e4jUQwl9s4mx3eI.editorEnd":"0","file.7gFUaijL2e4jUQwl9s4mx3eI.editorScrollTop":"0","file.7gFUaijL2e4jUQwl9s4mx3eI.editorStart":"0","file.7gFUaijL2e4jUQwl9s4mx3eI.previewScrollTop":"0","file.7gFUaijL2e4jUQwl9s4mx3eI.publish":";","file.7gFUaijL2e4jUQwl9s4mx3eI.selectTime":"1427743072893","file.7gFUaijL2e4jUQwl9s4mx3eI.sync":";sync.gdrive.0B0eCVEhOzw7BYXVpazUzN2NrRmM;","file.7gFUaijL2e4jUQwl9s4mx3eI.title":"Mikro wyklad 3 ?","file.RBqorhwPbAgzoxLdCYjTeXHe.content":"### Czas systemowy:\n\n1.Proces macierzysty\n\n![enter image description here](http://student.agh.edu.pl/~mfudala/sysopy3_plots/syspar.svg)\n\n2.Procesy potomne ( łacznie )\n\n![enter image description here](http://student.agh.edu.pl/~mfudala/sysopy3_plots/syschild.svg)\n\n\n3.Sumaryczny czas z 1. i 2.\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/sysparchild.svg)\n\nKomentarz:\nCzas systemowy to czas, poświęcony na samo stworzenie procesu, jak widać `vfork` jest szybszy, ponieważ ma pamięć współdzieloną z procesem macierzystym i nie potrzebuje czasu na początkową kopie pamięci.\n\n\n\n### Czas użytkownika:\n\n1.Proces macierzysty\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/usrpar.svg)\n\n2.Procesy potomne ( łacznie )\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/usrchild.svg)\n\n3.Sumaryczny czas z 1. i 2.\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/usrparchild.svg)\n\n\nKomentarz:\nWykres dla samego procesu macierzystego jest bardzo nieregularny co wynika z tego, że ten czas jest bardzo bliski zera, ponieważ proces macierzysty praktycznie nic nie robi w trybie użytkownika.\nDla procesów potomnych wyraźnie widać przewagę czasową `clone_vfork` oraz `vfork`, wynika to z tego, że procesy tak utworzone w ten sposób mają pamięć współdzieloną z rodzicem i nie tracą czasu na tzw. copy-on-write czyli kopiowanie pamięci z procesu macierzystego dopiero przy próbie jej modyfikacji\n\n\n### Czas sumaryczny użytkownika i systemowy\n\n1.Proces macierzysty\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/sysusrpar.svg)\n\n2.Procesy potomne ( łacznie )\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/sysusrchild.svg)\n\n3.Sumaryczny czas z 1. i 2.\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/sysusrparchild.svg)\n\n### Czas rzeczywisty\n\n1.Proces macierzysty\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/realpar.svg)\n\n2.Procesy potomne ( łacznie )\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/realchild.svg)\n\n3.Sumaryczny czas z 1. i 2.\n\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/realparchild.svg)\n\n\n\n","file.RBqorhwPbAgzoxLdCYjTeXHe.editorEnd":"565","file.RBqorhwPbAgzoxLdCYjTeXHe.editorScrollTop":"0","file.RBqorhwPbAgzoxLdCYjTeXHe.editorStart":"565","file.RBqorhwPbAgzoxLdCYjTeXHe.previewScrollTop":"48","file.RBqorhwPbAgzoxLdCYjTeXHe.publish":";","file.RBqorhwPbAgzoxLdCYjTeXHe.selectTime":"1428061333066","file.RBqorhwPbAgzoxLdCYjTeXHe.sync":";sync.gdrive.0B0eCVEhOzw7BeUdBT0EyRVFsQTA;","file.RBqorhwPbAgzoxLdCYjTeXHe.title":"Sprawko sysop","file.Svq6d5AW4RPHeG7vwkidzvJ8.content":"\n## Sysopy\n\nStrona prowadzącego:\n\n\nLiteratura:\n\n\n\n---","file.Svq6d5AW4RPHeG7vwkidzvJ8.editorEnd":"33","file.Svq6d5AW4RPHeG7vwkidzvJ8.editorScrollTop":"0","file.Svq6d5AW4RPHeG7vwkidzvJ8.editorStart":"33","file.Svq6d5AW4RPHeG7vwkidzvJ8.previewScrollTop":"0","file.Svq6d5AW4RPHeG7vwkidzvJ8.publish":";","file.Svq6d5AW4RPHeG7vwkidzvJ8.selectTime":"1428836907753","file.Svq6d5AW4RPHeG7vwkidzvJ8.sync":";sync.gdrive.0B0eCVEhOzw7BWmZsNU5XZF9pT3c;","file.Svq6d5AW4RPHeG7vwkidzvJ8.title":"AGH 4 semestr","file.XIItPecZuR3Otluo3EprYokA.content":"## Wzory:\n\n### Optyka falowa\n\n#### Dyfrakcja, interferencja ( maksima )\n\n1. Maksimum interferencyjne:\n$$ dsin \\alpha = m \\lambda $$\n2. Maksimum dyfrakcyjne:\n$$ asin\\alpha = (m + 1/2) \\lambda $$\n3. Maksimum siatki dyfrakcyjnej:\n$$ dsin \\alpha = m \\lambda $$\n4. Maksimum w cienkich warstwach:\n$$ 2dsin \\alpha = (m + 1/2) \\frac{\\lambda}{n_2} $$\n5. Maksimum przy promieniach X w krysztale ( prawo Bragga ):\n$$ 2dsin \\alpha = m \\lambda $$ \n\n#### Rozkład natężenia dla:\n- Interferencji:\n$$ I(\\theta) = 4 I_0 cos^2 \\beta $$\ngdzie \n$$ \\beta = \\frac{\\pi dsin \\theta}{\\lambda} $$\n- Dyfrakcji:\n$I_m$- zerowe maksimum\nSama dyfrakcja:\n$$ I(\\theta) = I_m (\\frac{sin \\alpha}{\\alpha}) ^ 2 $$\n$$ \\alpha = \\frac{\\pi a sin(\\theta)}{\\lambda} $$\n- Dyfrakcja oraz interferencja:\n\n$$ I(\\theta) = I_m (cos^2 \\beta)(\\frac{sin \\alpha}{\\alpha})^2 $$\n\n#### Polaryzacja\nPrawo Malus'a:\n(przy polaryzacji zachodzi):\n$$ I = I_0 cos^2 \\beta $$\n\nKąt Brewster'a:\n( kąt przy którym dojdzie do polaryzacji odbitego )\n$$ \\theta = arctg(\\frac{n_2}{n_1}) $$\n\nKąt całkowitego wewnętrznego odbicia:\n\n$$ \\theta = arcsin(\\frac{n_2}{n_1}) $$\n\n### Termodynamika\n\nPromieniowanie termiczne:\n$$ P = \\sigma \\epsilon S T^4 $$\n\n\n\n\n### Światło kwanty\n\n$$ hv = W + E_{kmaks} $$\n\n$$ E_{kmaks} = e U_{ham} $$\n\n\n**Efekt comptona**:\nZderzenie z elektronem, nie powinno zmienić długości padającej fali co przewiduje teoria falowa, ale jednak zmienia o wartość:\n\n$$ \\Delta \\lambda = \\lambda ' - \\lambda = \\frac{h}{m_e c} (1 - cos \\theta) $$\n\nCo pokazuje że energia jest przekazywana w pakietach $hv$ gdyż przy zderzeniu zostaje zmieniona długość fali a więc widać wpływ przekazania odrobiny energii kinetycznej elektronowi na długość fali, a co za tym idzie na częstotliwość fali co potwierdza teorie kwantową światła.\n\n**Prawo Wiena**: Długość fali na którą przypada maksimum jest odwrotnie proporcjonalne do temperatury \n\n**Zjawisko fotoelektryczne**:\nPolega na wyrzucaniu elektronów z powierzchni ciała stałego, pod wpływem padającego światła ( fotonów )\n\nDlaczego niezgodne z teorią falową:\n1. Istnieje częstotliwość poniżej, której zjawisko nie zachodzi ( nie ma wystarczającej energii na wyrwanie fotoelektronu )\n2. Energia kinetyczna maksymalna $ E_{kmax} $ nie zależy od natężenia światła !\n3. Klasycznie - energia falii rozłożona w przestrzeni $\\Rightarrow$ powinno być opóźnienie pomiędzy początkiem oświetlenia a wyrwanie elektronu. Nie dochodzi do takowego opóźnienia co jeszcze raz potwierdza fakt niezgodności z teorią falową.\n\n**Fale materii** ( de Brogile ):\n\n$$ \\lambda = \\frac{h}{p} $$\n\nDoświadczenie Davissona i Germera:\ndyfrakcja elektronów to potwierdzenie teorii de Brogile'a o tym, że materia ma naturę cząstkowo-falową\n\n\n\n### Model Bohr'a \n\nProblem modelu Rutherford'a - dlaczego elektron poruszając się ruchem przyspieszonym nie spada na jądra ? \n\n**Kwantowe postulaty Bohr'a** :\n\n- elektron może poruszać się tylko po ściśle określonych orbitach ( nieciągły rozkład )\n- elektron może znajdować się tylko w ściśle określonych stanach stacjonarnych, oraz jego energia całkowita pozostaje stała pomimo jego ruchu przyspieszonego\n- elektron wypromieniowuje falę elektromagnetyczną o częstotliwości $ v = (E_j - E_k)/h $  tylko wtedy gdy przeskakuje z orbity j o wyższej energii na orbitę k o niższej energii stanu stacjonarnego $E_k$\n\n\n$ E_k = \\frac{e^2}{8 \\pi \\epsilon_0 r} $\n\n$ E_p  = -\\frac{e^2}{4 \\pi \\epsilon_0 r}$\n\n$ \\frac{E_p}{E_k} = - 1/2 $\n\n$ E_c = -\\frac{e^2}{8 \\pi \\epsilon_0 r} < 0 $ !\n\nHipoteza Bohr'a kwantyzacji\n\n$ L = mvr = n \\frac{h}{2 \\pi} $\n\n$ E_n = E_1 / n^2 $\n\n$ r_n = n^2 r_1 $\n\nDokładne wzory wyprowadzamy z:\n\n$ \\frac{mv^2}{r} = \\frac{e^2}{4 \\pi \\epsilon_0 r^2} $\n\n\nCo daje wzór na energię, później przyrównjąc do pędu daje nam to promień skwantowany, później możemy wyliczyć energię skwantowaną.\n\nStan podstawowy atomu owodru $ - 13.6\\ eV $\n\nPrzejscie:\n$ hv = E_k - E_j $\n\n\nFala materii de Brogie'a:\n\nFala przebiega wzdłuż orbity kołowej i się powtarza \nfala zgodna w fazie z falami z poprzednich przebiegów:\n\n$ 2 \\pi r = n \\lambda $\n\n$ \\lambda = \\frac{h}{p} $\n\n$ \\Rightarrow L = n \\hbar $\n\nFala stojąca ! \nKwantyzacja długości fal wynikająca z ograniczeń nałożonych na falę.\n\nJest to uzasadnienie reguł kwantowania Bohr'a , ale nic poza tym...\n\nHeisenberg + Schrodinger = mechanika kwantowa ...\n\n### Mechanika kwantowa\n\n- elektron w stanie stacjonarnym może być opisany za pomocą fal stojących, wykorzystuje do tego związek de Brogile'a $ \\lambda = \\frac{h}{p} $ który łączy cząsteczki z falami\n- teoria ta określa prawa ruchu falowego cząstek w dowolnym układzie mikroskopowym\n- Formułuje równanie opisujące zachowanie sie funkcji falowej oraz związek pomiedzy zachowanie sie czastek a zachowaniem funkcji falowej\n\nTeoria Schrodinger'a to uogólnienie hipotezy de Brogile'a\n\n\n$| \\Psi | ^2$ - interpretacja:\noznacza prawdopodobieństwo na jednostkę czasu, że w pobliżu przedziału x, x + dx znajdziemy cząstke.\n\n$ | \\Psi |^2 $ to gęstość prawdobodobieństwa\n\nWarunek normalizacyjny \n$ \\int_{-\\infty}^{\\infty} |\\Psi|^2dx = 1 $ \n\n\nFalę materii opisuje równanie Schrodinger'a:\n\n$ - \\frac{\\hbar^2}{2m} \\frac{\\partial^2 \\Psi}{\\partial x^2} = [ E - U(x) ]\\Psi $\n\n-> równanie w jednym wymiarze niezależne od czasu \n\nChcemy znaleźć funkcję falową oraz energię E, mając daną energię potencjalną wyrażającą siłę $U(x)$\n\n\nZadania:\n\n- cząstka swobodna:\n\n$ \\Psi(x) = Ae^{\\pm ikx} $\n\n- studnia potencjału $\\infty$:\n\n$ \\Psi(0) = 0 $\n\n$ \\Psi(L) = 0 $\n\nAnalogia do struny ( fala stojąca o węzłach w 0 i L )\n\n$ \\lambda = \\frac{2L}{n} $\n\n$ \\Psi(x) = A sin(kx) $\n\n$ E_k = \\frac{p^2}{2m} $\n\n$ \\lambda = \\frac{h}{p} $\n\nZ tego dostaniesz rozkład oraz energię ( skwantowaną ! )\n\n- studnia potencjału $U_0$\n\n$ \\frac{\\partial ^ 2 \\Psi}{\\partial x ^2} = \\frac{2m}{\\hbar^2} [E - U_0] \\Psi $\n\nFale przenikają do obszaru o potencjale $U_0$ niedostępnym z punkty widzenia fizyki klasycznej\n\n- tunelowanie elektronu przez barierę potencjału\n\n\n**Zasada nieoznaczoności Heisenberg'a**\nIloczyn nieoznaczoności pędu oraz nieoznaczoności położenia jest zawsze większy od $ \\hbar / 2 $\n\n$ \\Delta p_x \\Delta x \\ge \\frac{\\hbar}{2} $\n\nOraz dotyczy pomiaru energi i czasu mierzenia tej energii:\n\n$ \\Delta E \\Delta t \\ge \\frac{\\hbar}{2} $\n\n$ \\Delta E = h \\Delta v $ \n\n$ \\Rightarrow h \\Delta v \\Delta t \\ge \\frac{\\hbar}{2} $\n\n\nFunckja falowa \n\nOgólnie  $ \\Psi(x,t) = Ae^{i(kx - \\omega t)} $\n\n\n### Teoria Schrodingera atomu wodoru \n\nTrójwymiarowa funkcja falowa zależy od 3 liczb kwantowy. Na każdą współrzędną przestrzenną przypada jedna liczba kwantowa\n\nFunkcję falową można przedstawić \n\n$ \\Psi_{n, l, m_l}(r, \\theta, \\phi)  = R_{n, l} Y_{l, m_l}(\\theta, \\phi)$\n\nWarunki na liczby kwantowe:\n\ngłówna liczba kwantowa\n$ n = 1, 2, 3, ... $ \nazymutalna liczba kwantowa\n$ l = 0, 1, 2, 3, ..., n - 1 $ \nmagnetyczna liczba kwantowa\n$m_l = -l, -(l - 1), ... ,0, ..., l $ \n\n\nRadialna gęstość prawdopobobieństwa:\n\n$ P_{n, l}(r) = r^2 |R_{n,l}(r)|^2 $\n\nOrbitale - wykresy kątowej gęstości prawodopobdobieństwa\n\n\n### Atomy wieloelektronowe\n\nn - kwantowanie energii całkowitej elektronu \n$ l, m_l $ - kwantowanie przestrzenne momentu pędu elektronu\n\n$ s $ - wewnętrzny moment pędu, spin, skwantowany przestrzennie \n\nMoment pędu atomu to suma momentów oribtalnych i spinów wszystkich atomow w elektronie\n\nNie można dokładnie wyznaczyć momentu pędu ( wszystkich składowych )\n\nMoment pędu \n$ L = \\frac{h}{2 \\pi} \\sqrt{(l^2 + l)} $\n$ L_z = \\frac{h}{2 \\pi} m_l $\n\n\n\n**Zakaz Pauliego**:\nW atomie wieloelektronowym w tym samym stanie kwantowym znajduje się co najwyżej jeden elektron $  \\Rightarrow $ w atomie elektronowym elektornu muszę różnić się przynajmniej jedną liczbą kwantową\n\nZakaz Pauliego grupy:\n2, 8, 8, 18, 18, 32\n\n$ Z_{ef} $ - efektywne Z\n$ E = E_1 \\frac{Z^2}{n^2} $\n\nW atomach wieloelektronowych dochodzi do ekranowania jądra atomowego:\n\n- elektrony na niższych powłokach zmniejszają przyciąganie przez jądro\n- na wyższych nie wpływają\n\n\n**Postulaty Slatera**:\n\n- orbitale wodoropodone\n- uwzględniamy ekranowanie elektronów \n- wprowadzamy efektywną liczbę atomową $Z_{ef}$\n- korzystamy ze wzoru na energię elektronu $ E = -13.6 \\frac{Z_{ef}^2}{n^2}\\  [eV] $\n\nPromienie X:\n\n\ndlaczego na $ \\lambda_{min} $ zależy tylko od $ U $ i jest takie samo dla każdego materiału ?\n\n\nbo:\n\n$ \\frac{hc}{\\lambda_{min}} = eU $\n\n$ \\Rightarrow \\lambda_{min} = \\frac{hc}{eU} $\n\n\n**Prawo Moseleya** - dotyczy zależności częstotliwości promieni X od materiału ( Z - liczba atomowa )\n\n\n$ v = (Z - a)^2 Rc ( 1 / k^2 - 1/ j^2 )$\n\n\nRozkład Boltzman'a - wyjaśnia ( prawdopodobieństwem ) w jaki sposób cząstki układu zajmują różne stany energ\n\n$ N(E) = Ae^{-\\frac{E}{kT}} $\n\nW laserze potrzebujemy inwersji obsadzeń aby nie dochodziło do absorbcji promieniowania przy której emisja wymuszona jest znikoma \n\n### Fizyka jądrowa \n\nPromień jądra:\n\n$ R = (1.2 * 10^{-15}) A ^{1/3} $\n\nRozpad $\\alpha$\nZ > 82 \n\nSamorzutnie, czastka alfa unosi energię \n\nRozpad $ \\beta $\n\n$ \\beta^- $\nneutron w proton \n\n$ n \\rightarrow p + e^- + \\bar{v} $\n\n$ p \\rightarrow n + e^+ v $\n\nPromieniowanie gamma:\nduza energia, towarzyszy rozpada beta i alfa\n\nReakcja rozszczepienia:\nCieżkie jądra na 2 -> dwa mniejsze silniej wiazane, i mniejsza masa, wydziela się energia !\nMozna bombardowac elektronami\n\nSynteza:\nmasa dowch lekki = masa nowego\n\nwydziela sie energia roznicy mas\n\n\n\n## Wskazówki\n\nLiczba masowa = Masa molowa\n\n\n## Konwersje, stałe\n\n$$ 1\\ cal = 4.19\\ J $$\n$$ 1\\ eV = 1.6 \\cdot 10^{-19}$$\n","file.XIItPecZuR3Otluo3EprYokA.editorEnd":"71","file.XIItPecZuR3Otluo3EprYokA.editorScrollTop":"59","file.XIItPecZuR3Otluo3EprYokA.editorStart":"71","file.XIItPecZuR3Otluo3EprYokA.previewScrollTop":"159","file.XIItPecZuR3Otluo3EprYokA.publish":";","file.XIItPecZuR3Otluo3EprYokA.selectTime":"1427584332180","file.XIItPecZuR3Otluo3EprYokA.sync":";sync.gdrive.0B0eCVEhOzw7BQktWdjk3S2lSZ3M;","file.XIItPecZuR3Otluo3EprYokA.title":"Fizyga","file.cqFXM82n2lqR7ijuhHFUcQN0.content":"## NodeWebkit\n\n**Distribution**\n\nhttps://github.com/mllrsohn/grunt-node-webkit-builder\n> Let's you build your node-webkit apps for osx, win, and linux with grunt. It will download the prebuilt binaries for a specify version, unpacks it, creates a release folder, create the app.nw file for a specified directory and copys the app.nw file where it belongs.\n\n\n`npm install grunt-node-webkit-builder --save-dev`\n\n\n**Gruntfile example for all platforms**\n```javascript \ngrunt.initConfig({\n  nodewebkit: {\n    options: {\n        platforms: ['win','osx','linux'],\n        buildDir: './webkitbuilds', // Where the build version of my node-webkit app is saved\n    },\n    src: ['./example/public/**/*'] // Your node-webkit app\n  },\n})\n```\n\n#### Full example:\n\nhttps://github.com/mllrsohn/grunt-node-webkit-builder/tree/master/example\n\n\nBuild it:\n```\nnpm install\ncd public/ && npm install && cd -\ngrunt nodewebkit\n```\n\n\nOutputs ready to fire executables for all platforms\n\n**Works on 32/64 bit: Mac/Win/Linux** ","file.cqFXM82n2lqR7ijuhHFUcQN0.editorEnd":"329","file.cqFXM82n2lqR7ijuhHFUcQN0.editorScrollTop":"0","file.cqFXM82n2lqR7ijuhHFUcQN0.editorStart":"329","file.cqFXM82n2lqR7ijuhHFUcQN0.previewScrollTop":"60","file.cqFXM82n2lqR7ijuhHFUcQN0.publish":";","file.cqFXM82n2lqR7ijuhHFUcQN0.selectTime":"1428836475506","file.cqFXM82n2lqR7ijuhHFUcQN0.sync":";sync.gdrive.0B0eCVEhOzw7BaWFfOWVXWkwwM2s;","file.cqFXM82n2lqR7ijuhHFUcQN0.title":"BVC","file.lRMhkJhLonXInzEL20IU2AFu.content":"\n## Theory / Hardware:\n\n\n## Algorithms:\n\n### Multiplication:\n\n\n**SHIFT/ADD sequential** ( works only for multiplicand > 0 )\n\n**Booth's algorithm** ( works for negative and positive )\n","file.lRMhkJhLonXInzEL20IU2AFu.editorEnd":"182","file.lRMhkJhLonXInzEL20IU2AFu.editorScrollTop":"0","file.lRMhkJhLonXInzEL20IU2AFu.editorStart":"182","file.lRMhkJhLonXInzEL20IU2AFu.previewScrollTop":"0","file.lRMhkJhLonXInzEL20IU2AFu.publish":";","file.lRMhkJhLonXInzEL20IU2AFu.selectTime":"1428680255744","file.lRMhkJhLonXInzEL20IU2AFu.sync":";sync.gdrive.0B0eCVEhOzw7BbDRxZm4xRF8xVmM;","file.lRMhkJhLonXInzEL20IU2AFu.title":"Computer's Arithmetic","file.list":";file.XIItPecZuR3Otluo3EprYokA;file.7gFUaijL2e4jUQwl9s4mx3eI;file.6EG4REUWBttCZnGypC5cGz80;file.cqFXM82n2lqR7ijuhHFUcQN0;file.4eyl0ICaPfL3V9NIDKXYomw4;file.RBqorhwPbAgzoxLdCYjTeXHe;file.xlbYaRo0TuQJLbmoUFMo5yae;file.lRMhkJhLonXInzEL20IU2AFu;file.nqr3bbr1aHD7ShZSMK1GXa4E;file.Svq6d5AW4RPHeG7vwkidzvJ8;","file.nqr3bbr1aHD7ShZSMK1GXa4E.content":"\n### Kurs Deep Learning\nMail: https://mail.google.com/mail/u/0/#search/craftinity/14c50258a64d212e\nStrona kursu: ...\n\n---- \n\n\n#### Zajęcia 2\n\n**Pochodna z funkcji sigoid** $ \\sigma $\nFunkcja **softmax**\n**Backrop** -> wyprowadzenie\n\nGradient Descent -> **Stochastic Gradient Descent**\n\nPaper Hinton'a \n\n**Homework**: Wyślij rozwiązanie + repo ( są rankingi i punktacje )\nhttps://mail.google.com/mail/u/0/#search/craftinity/14c50258a64d212e\n\n---\n\n#### Zajęcia 3","file.nqr3bbr1aHD7ShZSMK1GXa4E.editorEnd":"124","file.nqr3bbr1aHD7ShZSMK1GXa4E.editorScrollTop":"159","file.nqr3bbr1aHD7ShZSMK1GXa4E.editorStart":"124","file.nqr3bbr1aHD7ShZSMK1GXa4E.previewScrollTop":"161","file.nqr3bbr1aHD7ShZSMK1GXa4E.publish":";","file.nqr3bbr1aHD7ShZSMK1GXa4E.selectTime":"1428835681761","file.nqr3bbr1aHD7ShZSMK1GXa4E.sync":";sync.gdrive.0B0eCVEhOzw7BUjVJbmV6bUJJLXM;","file.nqr3bbr1aHD7ShZSMK1GXa4E.title":"Craftinity Deep Learning","file.xlbYaRo0TuQJLbmoUFMo5yae.content":"# My notes for Cormen's book ( brainstorm, exercises, solutions )\n\n## 22. Graphs\n\n### 22.1 Representation of graphs\n\n**Exercises:**\n\n**22.1-1.**  Out(if computing size of list is $ O(1) $): $ O(V) $ if not $ O (V + E) In: $ O(V + E) $\n\n**22.1-2.** Easy. Solved.\n\n**22.1-3.** :\n\n- Matrix: transpose like in normal matrix. In place, and time complexity $ O(V^2) $\n- List: create new list, for every $(u,v) \\in E$ add u to v entry in list, running time complexity is $ O(V + E) $\n\n\n**22.1-4** For each vertex, add all adjacent vertexes to, a HashSet ( insertion time $O(1)$ ) then make list from this HashSet ( $O(E) $ - ) ( can be better ? ) - and give it to current vertex in newly created list.\n\n**22.1-5** su\n\n\n\n\n## 25. All-Pairs Shortest Paths\n\n\n","file.xlbYaRo0TuQJLbmoUFMo5yae.editorEnd":"716","file.xlbYaRo0TuQJLbmoUFMo5yae.editorScrollTop":"197","file.xlbYaRo0TuQJLbmoUFMo5yae.editorStart":"716","file.xlbYaRo0TuQJLbmoUFMo5yae.previewScrollTop":"423","file.xlbYaRo0TuQJLbmoUFMo5yae.publish":";","file.xlbYaRo0TuQJLbmoUFMo5yae.selectTime":"1428835668752","file.xlbYaRo0TuQJLbmoUFMo5yae.sync":";sync.gdrive.0B0eCVEhOzw7BeVRBT2QzX2dIQ3M;","file.xlbYaRo0TuQJLbmoUFMo5yae.title":"Cormen notes","folder.3FNYKxbGKFQc2Yubys574x8v.files":";file.nqr3bbr1aHD7ShZSMK1GXa4E;","folder.3FNYKxbGKFQc2Yubys574x8v.name":"ML","folder.MtAii0UZaZMUUBoncXSlyFnc.files":";","folder.MtAii0UZaZMUUBoncXSlyFnc.name":"Reactive","folder.N9Vs2k7XbTvMWiWfi5HZY4Xx.files":";file.lRMhkJhLonXInzEL20IU2AFu;file.4eyl0ICaPfL3V9NIDKXYomw4;","folder.N9Vs2k7XbTvMWiWfi5HZY4Xx.name":"MOWNiT","folder.NYDeVE2Le9AZhMtethw68z33.files":";file.RBqorhwPbAgzoxLdCYjTeXHe;","folder.NYDeVE2Le9AZhMtethw68z33.name":"OS","folder.QGe2AQUJCKnkpv7zBY5NjxUm.files":";file.XIItPecZuR3Otluo3EprYokA;","folder.QGe2AQUJCKnkpv7zBY5NjxUm.name":"Physics","folder.VgnYj4b67MCWxqNs9xDWCQXN.files":";file.6EG4REUWBttCZnGypC5cGz80;file.7gFUaijL2e4jUQwl9s4mx3eI;","folder.VgnYj4b67MCWxqNs9xDWCQXN.name":"Micro","folder.eXrpenpz1OuCv9YV5C7yVovW.files":";file.xlbYaRo0TuQJLbmoUFMo5yae;","folder.eXrpenpz1OuCv9YV5C7yVovW.name":"Algo","folder.fkJycVbonUsmbm8qGzSdQwxu.files":";","folder.fkJycVbonUsmbm8qGzSdQwxu.name":"Scala","folder.list":";folder.NYDeVE2Le9AZhMtethw68z33;folder.eXrpenpz1OuCv9YV5C7yVovW;folder.VgnYj4b67MCWxqNs9xDWCQXN;folder.fkJycVbonUsmbm8qGzSdQwxu;folder.MtAii0UZaZMUUBoncXSlyFnc;folder.3FNYKxbGKFQc2Yubys574x8v;folder.N9Vs2k7XbTvMWiWfi5HZY4Xx;folder.QGe2AQUJCKnkpv7zBY5NjxUm;","frontWindowId":"2Of9aZypKWX88nhinXGDVmsA","gdrive.autosyncConfig":"{\"mode\":\"all\",\"parentId\":\"0B0eCVEhOzw7BfnJucGZrc1NPOFk4WkpvRGkxaGpWWFBHZ2xkTWlpT2tDZER4U01rR3dHM1E\"}","gdrive.exportPreferences":"{\"gdrive-parentid\":\"\"}","gdrive.importPreferences":"{}","google.gdrive0.authUser":"0","google.gdrive0.gdrive.lastChangeId":"61919","google.gdrive0.permissions":"profile;gdrive","google.gdrive0.userId":"108902931861279202823","settings":"{\"layoutOrientation\":\"horizontal\",\"editMode\":\"ltr\",\"lazyRendering\":true,\"editorFontClass\":\"font-rich\",\"fontSizeRatio\":1,\"maxWidthRatio\":1,\"cursorFocusRatio\":0.5,\"defaultContent\":\"\\n\\n\\n> Written with [StackEdit](https://stackedit.io/).\",\"commitMsg\":\"Published with https://stackedit.io/\",\"conflictMode\":\"merge\",\"markdownMimeType\":\"text/plain\",\"gdriveMultiAccount\":1,\"gdriveFullAccess\":true,\"dropboxFullAccess\":true,\"githubFullAccess\":true,\"template\":\"<!DOCTYPE html>\\n<html>\\n<head>\\n<meta charset=\\\"utf-8\\\">\\n<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n<title><%= documentTitle %></title>\\n<link rel=\\\"stylesheet\\\" href=\\\"https://stackedit.io/res-min/themes/base.css\\\" />\\n<script type=\\\"text/javascript\\\" src=\\\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML\\\"></script>\\n</head>\\n<body><div class=\\\"container\\\"><%= documentHTML %></div></body>\\n</html>\",\"pdfTemplate\":\"<!DOCTYPE html>\\n<html>\\n<head>\\n<meta charset=\\\"utf-8\\\">\\n<title><%= documentTitle %></title>\\n<link rel=\\\"stylesheet\\\" href=\\\"http://localhost/res-min/themes/base.css\\\" />\\n<script type=\\\"text/x-mathjax-config\\\">\\nMathJax.Hub.Config({ messageStyle: \\\"none\\\" });\\n</script>\\n<script type=\\\"text/javascript\\\" src=\\\"http://localhost/res/bower-libs/MathJax/MathJax.js?config=TeX-AMS_HTML\\\"></script>\\n</head>\\n<body><%= documentHTML %></body>\\n</html>\",\"pdfOptions\":\"{\\n    \\\"marginTop\\\": 25,\\n    \\\"marginRight\\\": 25,\\n    \\\"marginBottom\\\": 25,\\n    \\\"marginLeft\\\": 25,\\n    \\\"pageSize\\\": \\\"A4\\\"\\n}\",\"couchdbUrl\":\"https://stackedit.smileupps.com/documents\",\"extensionSettings\":{\"yamlFrontMatterParser\":{},\"markdownSectionParser\":{},\"partialRendering\":{\"enabled\":true},\"buttonMarkdownSyntax\":{\"enabled\":true},\"googleAnalytics\":{\"enabled\":true},\"twitter\":{},\"dialogAbout\":{},\"dialogManagePublication\":{},\"dialogManageSynchronization\":{},\"dialogManageSharing\":{},\"dialogOpenHarddrive\":{},\"documentTitle\":{},\"documentSelector\":{\"orderBy\":\"mru\",\"shortcutPrevious\":\"Ctrl+[\",\"shortcutNext\":\"Ctrl+]\",\"enabled\":true},\"documentPanel\":{},\"documentManager\":{},\"workingIndicator\":{},\"notifications\":{\"timeout\":8000,\"enabled\":true},\"umlDiagrams\":{\"flowchartOptions\":\"{\\n   \\\"line-width\\\": 2,\\n   \\\"font-family\\\": \\\"sans-serif\\\",\\n   \\\"font-weight\\\": \\\"normal\\\"\\n}\",\"enabled\":true},\"markdownExtra\":{\"extensions\":[\"fenced_code_gfm\",\"tables\",\"def_list\",\"attr_list\",\"footnotes\",\"smartypants\",\"strikethrough\",\"newlines\"],\"intraword\":true,\"comments\":true,\"highlighter\":\"highlight\",\"enabled\":true},\"toc\":{\"marker\":\"\\\\[(TOC|toc)\\\\]\",\"maxDepth\":6,\"button\":true,\"enabled\":true},\"mathJax\":{\"tex\":\"{}\",\"tex2jax\":\"{ inlineMath: [[\\\"$\\\",\\\"$\\\"],[\\\"\\\\\\\\\\\\\\\\(\\\",\\\"\\\\\\\\\\\\\\\\)\\\"]], displayMath: [[\\\"$$\\\",\\\"$$\\\"],[\\\"\\\\\\\\[\\\",\\\"\\\\\\\\]\\\"]], processEscapes: true }\",\"enabled\":true},\"emailConverter\":{\"enabled\":true},\"scrollSync\":{\"enabled\":true},\"buttonSync\":{\"syncPeriod\":180000,\"syncShortcut\":\"mod+s\",\"enabled\":true},\"buttonPublish\":{},\"buttonStat\":{\"name1\":\"Characters\",\"value1\":\"\\\\S\",\"name2\":\"Words\",\"value2\":\"\\\\S+\",\"name3\":\"Paragraphs\",\"value3\":\"\\\\S.*\",\"enabled\":true},\"buttonHtmlCode\":{\"template\":\"<%= documentHTML %>\",\"enabled\":true},\"buttonViewer\":{\"enabled\":true},\"welcomeTour\":{},\"shortcuts\":{\"mapping\":\"{\\n    'mod+b': bindPagedownButton('bold'),\\n    'mod+i': bindPagedownButton('italic'),\\n    'mod+l': bindPagedownButton('link'),\\n    'mod+q': bindPagedownButton('quote'),\\n    'mod+k': bindPagedownButton('code'),\\n    'mod+g': bindPagedownButton('image'),\\n    'mod+o': bindPagedownButton('olist'),\\n    'mod+u': bindPagedownButton('ulist'),\\n    'mod+h': bindPagedownButton('heading'),\\n    'mod+r': bindPagedownButton('hr'),\\n    'mod+z': bindPagedownButton('undo'),\\n    'mod+y': bindPagedownButton('redo'),\\n    'mod+shift+z': bindPagedownButton('redo'),\\n    'mod+m': function(evt) {\\n        $('.button-open-discussion').click();\\n        evt.preventDefault();\\n    },\\n    '= = > space': function() {\\n        expand('==> ', '⇒ ');\\n    },\\n    '< = = space': function() {\\n        expand('<== ', '⇐ ');\\n    },\\n    'S t a c k E d i t': function() {\\n        eventMgr.onMessage(\\\"You are stunned!!! Aren't you?\\\");\\n    }\\n}\\n\",\"enabled\":true,\"code\":\"{\\n    'mod+b': bindPagedownButton('bold'),\\n    'mod+i': bindPagedownButton('italic'),\\n    'mod+l': bindPagedownButton('link'),\\n    'mod+q': bindPagedownButton('quote'),\\n    'mod+k': bindPagedownButton('code'),\\n    'mod+g': bindPagedownButton('image'),\\n    'mod+o': bindPagedownButton('olist'),\\n    'mod+u': bindPagedownButton('ulist'),\\n    'mod+h': bindPagedownButton('heading'),\\n    'mod+r': bindPagedownButton('hr'),\\n    'mod+z': bindPagedownButton('undo'),\\n    'mod+y': bindPagedownButton('redo'),\\n    'mod+shift+z': bindPagedownButton('redo'),\\n    'mod+m': function(evt) {\\n        $('.button-open-discussion').click();\\n        evt.preventDefault();\\n    },\\n    '= = > space': function() {\\n        expand('==> ', '⇒ ');\\n    },\\n    '< = = space': function() {\\n        expand('<== ', '⇐ ');\\n    },\\n    'S t a c k E d i t': function() {\\n        eventMgr.onMessage(\\\"You are stunned!!! Aren't you?\\\");\\n    }\\n}\\n\"},\"userCustom\":{\"code\":\"\",\"enabled\":true},\"comments\":{},\"findReplace\":{\"findReplaceShortcut\":\"mod+f\",\"enabled\":true},\"htmlSanitizer\":{\"enabled\":true}}}","sync.gdrive.0B0eCVEhOzw7BQktWdjk3S2lSZ3M":"{\"id\":\"0B0eCVEhOzw7BQktWdjk3S2lSZ3M\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkzMjg5OQ\\\"\",\"contentCRC\":\"7d41ba4f\",\"titleCRC\":\"b34ae267\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"## Wzory:\\n\\n### Optyka falowa\\n\\n#### Dyfrakcja, interferencja ( maksima )\\n\\n1. Maksimum interferencyjne:\\n$$ dsin \\\\alpha = m \\\\lambda $$\\n2. Maksimum dyfrakcyjne:\\n$$ asin\\\\alpha = (m + 1/2) \\\\lambda $$\\n3. Maksimum siatki dyfrakcyjnej:\\n$$ dsin \\\\alpha = m \\\\lambda $$\\n4. Maksimum w cienkich warstwach:\\n$$ 2dsin \\\\alpha = (m + 1/2) \\\\frac{\\\\lambda}{n_2} $$\\n5. Maksimum przy promieniach X w krysztale ( prawo Bragga ):\\n$$ 2dsin \\\\alpha = m \\\\lambda $$ \\n\\n#### Rozkład natężenia dla:\\n- Interferencji:\\n$$ I(\\\\theta) = 4 I_0 cos^2 \\\\beta $$\\ngdzie \\n$$ \\\\beta = \\\\frac{\\\\pi dsin \\\\theta}{\\\\lambda} $$\\n- Dyfrakcji:\\n$I_m$- zerowe maksimum\\nSama dyfrakcja:\\n$$ I(\\\\theta) = I_m (\\\\frac{sin \\\\alpha}{\\\\alpha}) ^ 2 $$\\n$$ \\\\alpha = \\\\frac{\\\\pi a sin(\\\\theta)}{\\\\lambda} $$\\n- Dyfrakcja oraz interferencja:\\n\\n$$ I(\\\\theta) = I_m (cos^2 \\\\beta)(\\\\frac{sin \\\\alpha}{\\\\alpha})^2 $$\\n\\n#### Polaryzacja\\nPrawo Malus'a:\\n(przy polaryzacji zachodzi):\\n$$ I = I_0 cos^2 \\\\beta $$\\n\\nKąt Brewster'a:\\n( kąt przy którym dojdzie do polaryzacji odbitego )\\n$$ \\\\theta = arctg(\\\\frac{n_2}{n_1}) $$\\n\\nKąt całkowitego wewnętrznego odbicia:\\n\\n$$ \\\\theta = arcsin(\\\\frac{n_2}{n_1}) $$\\n\\n### Termodynamika\\n\\nPromieniowanie termiczne:\\n$$ P = \\\\sigma \\\\epsilon S T^4 $$\\n\\n\\n\\n\\n### Światło kwanty\\n\\n$$ hv = W + E_{kmaks} $$\\n\\n$$ E_{kmaks} = e U_{ham} $$\\n\\n\\n**Efekt comptona**:\\nZderzenie z elektronem, nie powinno zmienić długości padającej fali co przewiduje teoria falowa, ale jednak zmienia o wartość:\\n\\n$$ \\\\Delta \\\\lambda = \\\\lambda ' - \\\\lambda = \\\\frac{h}{m_e c} (1 - cos \\\\theta) $$\\n\\nCo pokazuje że energia jest przekazywana w pakietach $hv$ gdyż przy zderzeniu zostaje zmieniona długość fali a więc widać wpływ przekazania odrobiny energii kinetycznej elektronowi na długość fali, a co za tym idzie na częstotliwość fali co potwierdza teorie kwantową światła.\\n\\n**Prawo Wiena**: Długość fali na którą przypada maksimum jest odwrotnie proporcjonalne do temperatury \\n\\n**Zjawisko fotoelektryczne**:\\nPolega na wyrzucaniu elektronów z powierzchni ciała stałego, pod wpływem padającego światła ( fotonów )\\n\\nDlaczego niezgodne z teorią falową:\\n1. Istnieje częstotliwość poniżej, której zjawisko nie zachodzi ( nie ma wystarczającej energii na wyrwanie fotoelektronu )\\n2. Energia kinetyczna maksymalna $ E_{kmax} $ nie zależy od natężenia światła !\\n3. Klasycznie - energia falii rozłożona w przestrzeni $\\\\Rightarrow$ powinno być opóźnienie pomiędzy początkiem oświetlenia a wyrwanie elektronu. Nie dochodzi do takowego opóźnienia co jeszcze raz potwierdza fakt niezgodności z teorią falową.\\n\\n**Fale materii** ( de Brogile ):\\n\\n$$ \\\\lambda = \\\\frac{h}{p} $$\\n\\nDoświadczenie Davissona i Germera:\\ndyfrakcja elektronów to potwierdzenie teorii de Brogile'a o tym, że materia ma naturę cząstkowo-falową\\n\\n\\n\\n### Model Bohr'a \\n\\nProblem modelu Rutherford'a - dlaczego elektron poruszając się ruchem przyspieszonym nie spada na jądra ? \\n\\n**Kwantowe postulaty Bohr'a** :\\n\\n- elektron może poruszać się tylko po ściśle określonych orbitach ( nieciągły rozkład )\\n- elektron może znajdować się tylko w ściśle określonych stanach stacjonarnych, oraz jego energia całkowita pozostaje stała pomimo jego ruchu przyspieszonego\\n- elektron wypromieniowuje falę elektromagnetyczną o częstotliwości $ v = (E_j - E_k)/h $  tylko wtedy gdy przeskakuje z orbity j o wyższej energii na orbitę k o niższej energii stanu stacjonarnego $E_k$\\n\\n\\n$ E_k = \\\\frac{e^2}{8 \\\\pi \\\\epsilon_0 r} $\\n\\n$ E_p  = -\\\\frac{e^2}{4 \\\\pi \\\\epsilon_0 r}$\\n\\n$ \\\\frac{E_p}{E_k} = - 1/2 $\\n\\n$ E_c = -\\\\frac{e^2}{8 \\\\pi \\\\epsilon_0 r} < 0 $ !\\n\\nHipoteza Bohr'a kwantyzacji\\n\\n$ L = mvr = n \\\\frac{h}{2 \\\\pi} $\\n\\n$ E_n = E_1 / n^2 $\\n\\n$ r_n = n^2 r_1 $\\n\\nDokładne wzory wyprowadzamy z:\\n\\n$ \\\\frac{mv^2}{r} = \\\\frac{e^2}{4 \\\\pi \\\\epsilon_0 r^2} $\\n\\n\\nCo daje wzór na energię, później przyrównjąc do pędu daje nam to promień skwantowany, później możemy wyliczyć energię skwantowaną.\\n\\nStan podstawowy atomu owodru $ - 13.6\\\\ eV $\\n\\nPrzejscie:\\n$ hv = E_k - E_j $\\n\\n\\nFala materii de Brogie'a:\\n\\nFala przebiega wzdłuż orbity kołowej i się powtarza \\nfala zgodna w fazie z falami z poprzednich przebiegów:\\n\\n$ 2 \\\\pi r = n \\\\lambda $\\n\\n$ \\\\lambda = \\\\frac{h}{p} $\\n\\n$ \\\\Rightarrow L = n \\\\hbar $\\n\\nFala stojąca ! \\nKwantyzacja długości fal wynikająca z ograniczeń nałożonych na falę.\\n\\nJest to uzasadnienie reguł kwantowania Bohr'a , ale nic poza tym...\\n\\nHeisenberg + Schrodinger = mechanika kwantowa ...\\n\\n### Mechanika kwantowa\\n\\n- elektron w stanie stacjonarnym może być opisany za pomocą fal stojących, wykorzystuje do tego związek de Brogile'a $ \\\\lambda = \\\\frac{h}{p} $ który łączy cząsteczki z falami\\n- teoria ta określa prawa ruchu falowego cząstek w dowolnym układzie mikroskopowym\\n- Formułuje równanie opisujące zachowanie sie funkcji falowej oraz związek pomiedzy zachowanie sie czastek a zachowaniem funkcji falowej\\n\\nTeoria Schrodinger'a to uogólnienie hipotezy de Brogile'a\\n\\n\\n$| \\\\Psi | ^2$ - interpretacja:\\noznacza prawdopodobieństwo na jednostkę czasu, że w pobliżu przedziału x, x + dx znajdziemy cząstke.\\n\\n$ | \\\\Psi |^2 $ to gęstość prawdobodobieństwa\\n\\nWarunek normalizacyjny \\n$ \\\\int_{-\\\\infty}^{\\\\infty} |\\\\Psi|^2dx = 1 $ \\n\\n\\nFalę materii opisuje równanie Schrodinger'a:\\n\\n$ - \\\\frac{\\\\hbar^2}{2m} \\\\frac{\\\\partial^2 \\\\Psi}{\\\\partial x^2} = [ E - U(x) ]\\\\Psi $\\n\\n-> równanie w jednym wymiarze niezależne od czasu \\n\\nChcemy znaleźć funkcję falową oraz energię E, mając daną energię potencjalną wyrażającą siłę $U(x)$\\n\\n\\nZadania:\\n\\n- cząstka swobodna:\\n\\n$ \\\\Psi(x) = Ae^{\\\\pm ikx} $\\n\\n- studnia potencjału $\\\\infty$:\\n\\n$ \\\\Psi(0) = 0 $\\n\\n$ \\\\Psi(L) = 0 $\\n\\nAnalogia do struny ( fala stojąca o węzłach w 0 i L )\\n\\n$ \\\\lambda = \\\\frac{2L}{n} $\\n\\n$ \\\\Psi(x) = A sin(kx) $\\n\\n$ E_k = \\\\frac{p^2}{2m} $\\n\\n$ \\\\lambda = \\\\frac{h}{p} $\\n\\nZ tego dostaniesz rozkład oraz energię ( skwantowaną ! )\\n\\n- studnia potencjału $U_0$\\n\\n$ \\\\frac{\\\\partial ^ 2 \\\\Psi}{\\\\partial x ^2} = \\\\frac{2m}{\\\\hbar^2} [E - U_0] \\\\Psi $\\n\\nFale przenikają do obszaru o potencjale $U_0$ niedostępnym z punkty widzenia fizyki klasycznej\\n\\n- tunelowanie elektronu przez barierę potencjału\\n\\n\\n**Zasada nieoznaczoności Heisenberg'a**\\nIloczyn nieoznaczoności pędu oraz nieoznaczoności położenia jest zawsze większy od $ \\\\hbar / 2 $\\n\\n$ \\\\Delta p_x \\\\Delta x \\\\ge \\\\frac{\\\\hbar}{2} $\\n\\nOraz dotyczy pomiaru energi i czasu mierzenia tej energii:\\n\\n$ \\\\Delta E \\\\Delta t \\\\ge \\\\frac{\\\\hbar}{2} $\\n\\n$ \\\\Delta E = h \\\\Delta v $ \\n\\n$ \\\\Rightarrow h \\\\Delta v \\\\Delta t \\\\ge \\\\frac{\\\\hbar}{2} $\\n\\n\\nFunckja falowa \\n\\nOgólnie  $ \\\\Psi(x,t) = Ae^{i(kx - \\\\omega t)} $\\n\\n\\n### Teoria Schrodingera atomu wodoru \\n\\nTrójwymiarowa funkcja falowa zależy od 3 liczb kwantowy. Na każdą współrzędną przestrzenną przypada jedna liczba kwantowa\\n\\nFunkcję falową można przedstawić \\n\\n$ \\\\Psi_{n, l, m_l}(r, \\\\theta, \\\\phi)  = R_{n, l} Y_{l, m_l}(\\\\theta, \\\\phi)$\\n\\nWarunki na liczby kwantowe:\\n\\ngłówna liczba kwantowa\\n$ n = 1, 2, 3, ... $ \\nazymutalna liczba kwantowa\\n$ l = 0, 1, 2, 3, ..., n - 1 $ \\nmagnetyczna liczba kwantowa\\n$m_l = -l, -(l - 1), ... ,0, ..., l $ \\n\\n\\nRadialna gęstość prawdopobobieństwa:\\n\\n$ P_{n, l}(r) = r^2 |R_{n,l}(r)|^2 $\\n\\nOrbitale - wykresy kątowej gęstości prawodopobdobieństwa\\n\\n\\n### Atomy wieloelektronowe\\n\\nn - kwantowanie energii całkowitej elektronu \\n$ l, m_l $ - kwantowanie przestrzenne momentu pędu elektronu\\n\\n$ s $ - wewnętrzny moment pędu, spin, skwantowany przestrzennie \\n\\nMoment pędu atomu to suma momentów oribtalnych i spinów wszystkich atomow w elektronie\\n\\nNie można dokładnie wyznaczyć momentu pędu ( wszystkich składowych )\\n\\nMoment pędu \\n$ L = \\\\frac{h}{2 \\\\pi} \\\\sqrt{(l^2 + l)} $\\n$ L_z = \\\\frac{h}{2 \\\\pi} m_l $\\n\\n\\n\\n**Zakaz Pauliego**:\\nW atomie wieloelektronowym w tym samym stanie kwantowym znajduje się co najwyżej jeden elektron $  \\\\Rightarrow $ w atomie elektronowym elektornu muszę różnić się przynajmniej jedną liczbą kwantową\\n\\nZakaz Pauliego grupy:\\n2, 8, 8, 18, 18, 32\\n\\n$ Z_{ef} $ - efektywne Z\\n$ E = E_1 \\\\frac{Z^2}{n^2} $\\n\\nW atomach wieloelektronowych dochodzi do ekranowania jądra atomowego:\\n\\n- elektrony na niższych powłokach zmniejszają przyciąganie przez jądro\\n- na wyższych nie wpływają\\n\\n\\n**Postulaty Slatera**:\\n\\n- orbitale wodoropodone\\n- uwzględniamy ekranowanie elektronów \\n- wprowadzamy efektywną liczbę atomową $Z_{ef}$\\n- korzystamy ze wzoru na energię elektronu $ E = -13.6 \\\\frac{Z_{ef}^2}{n^2}\\\\  [eV] $\\n\\nPromienie X:\\n\\n\\ndlaczego na $ \\\\lambda_{min} $ zależy tylko od $ U $ i jest takie samo dla każdego materiału ?\\n\\n\\nbo:\\n\\n$ \\\\frac{hc}{\\\\lambda_{min}} = eU $\\n\\n$ \\\\Rightarrow \\\\lambda_{min} = \\\\frac{hc}{eU} $\\n\\n\\n**Prawo Moseleya** - dotyczy zależności częstotliwości promieni X od materiału ( Z - liczba atomowa )\\n\\n\\n$ v = (Z - a)^2 Rc ( 1 / k^2 - 1/ j^2 )$\\n\\n\\nRozkład Boltzman'a - wyjaśnia ( prawdopodobieństwem ) w jaki sposób cząstki układu zajmują różne stany energ\\n\\n$ N(E) = Ae^{-\\\\frac{E}{kT}} $\\n\\nW laserze potrzebujemy inwersji obsadzeń aby nie dochodziło do absorbcji promieniowania przy której emisja wymuszona jest znikoma \\n\\n### Fizyka jądrowa \\n\\nPromień jądra:\\n\\n$ R = (1.2 * 10^{-15}) A ^{1/3} $\\n\\nRozpad $\\\\alpha$\\nZ > 82 \\n\\nSamorzutnie, czastka alfa unosi energię \\n\\nRozpad $ \\\\beta $\\n\\n$ \\\\beta^- $\\nneutron w proton \\n\\n$ n \\\\rightarrow p + e^- + \\\\bar{v} $\\n\\n$ p \\\\rightarrow n + e^+ v $\\n\\nPromieniowanie gamma:\\nduza energia, towarzyszy rozpada beta i alfa\\n\\nReakcja rozszczepienia:\\nCieżkie jądra na 2 -> dwa mniejsze silniej wiazane, i mniejsza masa, wydziela się energia !\\nMozna bombardowac elektronami\\n\\nSynteza:\\nmasa dowch lekki = masa nowego\\n\\nwydziela sie energia roznicy mas\\n\\n\\n\\n## Wskazówki\\n\\nLiczba masowa = Masa molowa\\n\\n\\n## Konwersje, stałe\\n\\n$$ 1\\\\ cal = 4.19\\\\ J $$\\n$$ 1\\\\ eV = 1.6 \\\\cdot 10^{-19}$$\\n\",\"title\":\"Fizyga\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","sync.gdrive.0B0eCVEhOzw7BTV84dUczVlVudzg":"{\"id\":\"0B0eCVEhOzw7BTV84dUczVlVudzg\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkyODQxMg\\\"\",\"contentCRC\":\"1e42b848\",\"titleCRC\":\"248a8f38\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"\\n\\n| Michał Fudała                   |                             |             24.03.2015              |\\n ----------------- | ---------------------------- | ------------------\\n| Metody Obliczeniowe w Nauce i Technice |             |  |\\n| Laboratorium 3: **Alebra liniowa**          |             |  |\\n\\n\\n\\n\\n\\n\\n# <center> Sprawozdanie </center>\\n\\n\\n\\n\\n### 1. Wstęp\\n\\nCelem ćwiczenia było napisanie programu rozwiązującego układ równań metodą LU oraz zbadanie czasu wykonania tego programu w zależności od wielkości macierzy ( N ). Zostały zbadane również czasy wykonania `gsl_linalg_solve_tridiag` dla macierzy trójdiagonalnych w zależności od N. \\nOstatnia część ćwiczenia polegała na zbadaniu działania oraz szybkości ( w zależności od N ) różnych funkcji BLAS ( Basic Linear Algebra Subprograms ) dla różnych poziomów.\\n\\nThe BLAS  are routines that provide standard building blocks for performing basic vector and matrix operations\\n\\n### 2. Wykonanie ćwiczenia\\n\\nPorównanie czasu metod:\\n\\n* dekompozycja LU \\n* `gsl_linal_solv_tridiag`\\n\\n\\nDo wyznaczania macierzy U i L został wykorzystany algorytm Doolittle'a.\\n\\nWzory ogólne na poszczególne elementy macierzy rozkładu przedstawiają się następująco:\\n\\n$$ u_{ij} = a_{ij} - \\\\sum_{k=1}^{i-1}  l_{ij}u_{kj} \\\\ dla \\\\ j\\\\in \\\\{i, i+1, \\\\dots, n\\\\}$$\\n\\n$$ l_{ij} = \\\\frac{1}{u_{ij}} ( a_{ji} - \\\\sum_{k=1}^{i-1}  l_{jk}u_{ki}) \\\\ dla \\\\ j\\\\in \\\\{i+1, i+1, \\\\dots, n\\\\}$$\\n\\nWyznaczanie wektora pomocniczego zostało zrealizowane według zależności:\\n\\n$$ y_i = v_i - \\\\sum_{j=0}^{i - 1}l_{ij}y_j \\\\ dla \\\\ i\\\\in\\\\{0,1,...,n-1\\\\}$$\\n\\nWyznaczanie wektora wynikowego zostało zrealizowane według zależności:\\n\\n$$ x_i = \\\\frac{1}{u_{ij}}(y_i - \\\\sum_{j = i +1}^{n-1} u_{ij}x_j ) \\\\ dla \\\\ i \\\\in \\\\{0,1,...,n-1\\\\} $$\\n\\nWażnym faktem, istotnym do zauważenia jest to, iż w przypadku wyznaczania y i iterujemy od $0$ do $n-1$, natomiast w przypadku $x$ i przeciwnie, od $n-1$ do $0$.\\n\\nKod implementacji rozwiązywania układu równań metodą LU:\\n\\n\\n```c\\n// lu decompose\\nint ludist(int n, gsl_matrix * A) {\\n    int i,j,k;\\n\\n    for(k = 0; k < n - 1; k++) {\\n        if(fabs(gsl_matrix_get(A, k, k)) < eps) return 0;\\n        double temp;\\n        for(i = k + 1; i < n; i++) {\\n            temp = gsl_matrix_get(A, i, k);\\n            gsl_matrix_set(A, i, k, temp / gsl_matrix_get(A, k, k));\\n        }\\n\\n        for(i = k + 1; i < n; i++) {\\n            for(j = k + 1; j < n; j++) {\\n                temp = gsl_matrix_get(A, i, j);\\n                gsl_matrix_set(A, i, j,temp - gsl_matrix_get(A, i, k) * gsl_matrix_get(A, k, j));\\n            }\\n        }\\n    }\\n  \\n    return 1;\\n}\\n\\n// lu solve\\nint lusolve(int n, gsl_matrix* A, gsl_vector * B, gsl_vector * X) {\\n    int    i,j;\\n    double s;\\n\\n    gsl_vector_set(X, 0, gsl_vector_get(B, 0));\\n\\n    for(i = 1; i < n; i++) {\\n        s = 0;\\n        for(j = 0; j < i; j++) {\\n            s += gsl_matrix_get(A, i, j) * gsl_vector_get(X, j);\\n        }\\n        gsl_vector_set(X, i, gsl_vector_get(B, i) - s);\\n    }\\n\\n    if(fabs(gsl_matrix_get(A, n - 1, n - 1)) < eps) return 0;\\n\\n    gsl_vector_set(X, n - 1, gsl_vector_get(X, n - 1) / gsl_matrix_get(A, n -1, n -1));\\n\\n    for(i = n - 2; i >= 0; i--) {\\n        s = 0;\\n        for(j = i + 1; j < n; j++) s += gsl_matrix_get(A, i, j) * gsl_vector_get(X, j);\\n        if(fabs(gsl_matrix_get(A, i, i)) < eps) return 0;\\n        gsl_vector_set(X, i, (gsl_vector_get(X, i) - s) / gsl_matrix_get(A, i, i));\\n    }\\n\\n    return 1;\\n}\\n\\n```\\n\\n\\nWykres czasu w zależności od różnej ilości danych ( dla LU oraz dla LU z macierzą trójdiagonalną ):\\n<center>![](http://student.agh.edu.pl/~mfudala/omg/lu_lu_tri.svg) </center>\\n\\n\\nKod wykorzystania `gsl_linalg_solve_tridiag`:\\n```c\\nint gsl_tri_solve(int N) {\\n    gsl_vector* vec1 = gen_vector(rand1d, N - 1, 0.0, 1000.0);\\n    gsl_vector* vec2 = gen_vector(rand1d, N, 0.0, 1000.0);\\n    gsl_vector* vec3 = gen_vector(rand1d, N - 1, 0.0, 1000.0);\\n    gsl_vector* b = gen_vector(rand1d, N, 0.0, 1000.0);\\n\\n    gsl_vector* x = gsl_vector_alloc(N);\\n\\n    gsl_linalg_solve_tridiag(vec2, vec1, vec3, b, x);\\n\\n    gsl_vector_free(vec1);\\n    gsl_vector_free(vec2);\\n    gsl_vector_free(vec3);\\n    gsl_vector_free(b);\\n    gsl_vector_free(x);\\n    return 1;\\n}\\n```\\n\\n\\nWykres w zależności od danych dla funkcji `gsl_linalg_solve_tridiag`\\n\\n<center> ![](http://student.agh.edu.pl/~mfudala/omg/gsl.svg) </center>\\n\\n\\nPorównanie metody `gsl_linalg_solve_tridiag` z implementacją LU:\\n\\n<center> ![](http://student.agh.edu.pl/~mfudala/omg/lu_gsl.svg) </center>\\n\\n\\n\\n\\n\\n\\n---\\n\\nPorównanie czasu metod:\\n\\n* dekompozycja LU dla macierzy trójdiagonalnej\\n* `gsl_linal_solv_tridiag`\\n\\n---\\n\\n\\nKod wykorzystania BLASów:\\n\\n**Level 1:**\\n```c\\nnt blas_l1(int N) {\\n    gsl_vector* vec1 = gen_vector(rand1d, N, 0.0, 1000.0);\\n    gsl_vector* vec2 = gen_vector(rand1d, N, 0.0, 1000.0);\\n    double res;\\n\\n    gsl_blas_ddot(vec1, vec2, &res);\\n\\n    gsl_vector_free(vec1);\\n    gsl_vector_free(vec2);\\n    return 1;\\n}\\n```\\n\\n\\n**Level 2**\\n\\n```c\\nint blas_l2(int N) {\\n    double alpha_random = rand1d(0.0);\\n    double beta_random = rand1d(0.0);\\n    gsl_matrix* A = gen_matrix(rand2d, N, 0.0, 1000.0);\\n    gsl_vector* x = gen_vector(rand1d, N, 0.0, 1000.0);\\n    gsl_vector* y = gen_vector(rand1d, N, 0.0, 1000.0);\\n\\n    gsl_blas_dgemv(CblasNoTrans, alpha_random, A, x, beta_random, y);\\n\\n    gsl_vector_free(x);\\n    gsl_vector_free(y);\\n    gsl_matrix_free(A);\\n    return 1;\\n}\\n```\\n\\n\\n**Level 3**\\n\\n```c\\nint blas_l3(int N) {\\n    double alpha_random = rand1d(0.0);\\n    double beta_random = rand1d(0.0);\\n    gsl_matrix* A = gen_matrix(rand2d, N, 0.0, 1000.0);\\n    gsl_matrix* B = gen_matrix(rand2d, N, 0.0, 1000.0);\\n    gsl_matrix* C = gen_matrix(rand2d, N, 0.0, 1000.0);\\n\\n    gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, alpha_random, A, B, beta_random, C);\\n\\n    gsl_matrix_free(A);\\n    gsl_matrix_free(B);\\n    gsl_matrix_free(C);\\n    return 1;\\n}\\n```\\n\\n\\nPorównanie czasu dla różnych poziomów BLAS dla metody:\\n\\n* 1 ( `gsl_blas_ddot` )\\n* 2 ( `gsl_blas_dgemv` )\\n* 3 ( `gsl_blas_dgemm` )\\n\\n\\nWykres z dużym \\\"step'em\\\" dla `gsl_blas_dgemv` ( poziom 2)\\n<center> ![](http://student.agh.edu.pl/~mfudala/omg/blas_sparse.svg) </center>\\n\\nPorównanie poszczególnych BLASów:\\n<center> ![Level1](http://student.agh.edu.pl/~mfudala/omg/blas.svg) </center>\\n\\n\\n\",\"title\":\"Sprawozdanie mownit lab3\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","sync.gdrive.0B0eCVEhOzw7BUGxSdkRucVBQT00":"{\"id\":\"0B0eCVEhOzw7BUGxSdkRucVBQT00\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkzMDc4Mw\\\"\",\"contentCRC\":\"1e7658d6\",\"titleCRC\":\"4e5dc201\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"<center> Sprawozdanie </center>\\n----\\n\\n\\n<center> ![tabelka](http://i.imgur.com/icRC7xw.png) </center>\\n\\n\\n### 1. Wstęp \\n\\nCelem ćwiczenia było poznanie możliwości 8-bitowych mikrokontrolerów o architekturze RISC oraz technik programowania tych mikrokontrolerów w językach wysokiego poziomu na przykładzie języka C.\\n\\n### 2. Wykonanie ćwiczenia\\n\\n\\n\\nPo zapoznaniu się z interfejsem programu AVR Studio 4 i skonfigurowaniem go, przeszliśmy do realizacji poszczególnych zadań.\\n\\n---\\nNagłowek każdego z plików:\\n\\n```c\\n#ifndef F_CPU\\n#define F_CPU 16000000 //okreslenie czestotliwosci pracy mikrokontrolera\\n#endif\\n#include <avr/io.h>\\n#include <util/delay.h>\\n```\\n\\n\\nFunkcje wykorzystywane we wszystkich następnych ćwiczeniach:\\n```c\\nvoid wait10(int delay) {\\n\\tint i;\\n\\tfor(i = 0; delay > i; i++) \\n\\t\\t_delay_ms(10);\\n}\\n\\nvoid set_porta_and_wait(char porta, char delay) {\\n\\tPORTA = porta;\\n\\t_delay_ms(delay);\\n}\\n```\\n\\n---\\n\\n####**a) Kod realizujący efekt wędrującego światła**:\\n\\n```c\\n#define DELAY 25\\n\\nint main(void) {\\n    DDRA = 0x0F; \\n    PORTA = 0b00000001;\\n    char temp = 0b00000001;\\n    do {\\n        for(int j = 0; 4 > j; j++) {\\n\\t        wait10(DELAY);\\n            temp <<= 1;\\n            PORTA = ~temp;\\n        }\\n        for(int j = 0; 4 > j; j++) {\\n            wait10(DELAY);\\n            temp >>= 1;\\n            PORTA = ~temp;\\n        }         \\n    } while(1);\\n    return 0;\\n}\\n```\\n\\n---\\n\\n####**b) Silnik krokowy - sterowanie jednofazowe**:\\n\\n$ A, B, C, D $ - uzwojenie silnika\\n\\nSekwencja napięć:\\n$ A \\\\rightarrow B \\\\rightarrow C \\\\rightarrow D $\\n\\nKod:\\n\\n```c\\n#define DELAY 10\\nvoid jednofazowe() {\\n    DDRA =  0b11111111;\\n    set_porta_and_wait(0b11111111, 30);\\n    do {\\n        set_porta_and_wait(0b11100000, DELAY);\\n        set_porta_and_wait(0b11010000, DELAY);\\n        set_porta_and_wait(0b10110000, DELAY);\\n        set_porta_and_wait(0b01110000, DELAY);\\n    } while(1);\\n}\\n```\\n\\n\\n####**c) Silnik krokowy - sterowanie dwufazowe**:\\n\\n\\n$ A, B, C, D $ - uzwojenie silnika\\n\\nSekwencja napięć:\\n$ AB \\\\rightarrow BC \\\\rightarrow CD \\\\rightarrow DA $\\n\\nKod:\\n\\n```c\\n#define DELAY 10\\nvoid dwufazowe() {\\n    DDRA =  0b11111111;\\n    set_porta_and_wait(0b11111111, 30);\\n    do {    \\n        set_porta_and_wait(0b00110000, DELAY);\\n        set_porta_and_wait(0b10010000, DELAY);\\n        set_porta_and_wait(0b11000000, DELAY);\\n        set_porta_and_wait(0b01100000, DELAY);\\n    } while(1);\\n}\\n```\\n\\n####**d) Silnik krokowy - sterowanie półkrokowe**:\\n\\n$ A, B, C, D $ - uzwojenie silnika\\n\\nSekwencja napięć:\\n\\n$ A \\\\rightarrow AB \\\\rightarrow B \\\\rightarrow BC \\\\rightarrow C \\\\rightarrow CD \\\\rightarrow D\\\\rightarrow DA \\\\rightarrow A $\\n\\nKod:\\n\\n```c\\n#define DELAY 10\\nvoid polkrokowe_prawo() {\\n    DDRA = 0b11111111;\\n    set_porta_and_wait(0b11111111, 30);\\n    do {    \\n        set_porta_and_wait(0b01110000, DELAY);\\n        set_porta_and_wait(0b00110000, DELAY);\\n        set_porta_and_wait(0b10110000, DELAY);\\n        set_porta_and_wait(0b10010000, DELAY);\\n        set_porta_and_wait(0b11010000, DELAY);\\n        set_porta_and_wait(0b11000000, DELAY);\\n        set_porta_and_wait(0b11100000, DELAY);\\n        set_porta_and_wait(0b01100000, DELAY);\\n    } while(1);\\n}\\n```\\n```c\\n#define DELAY 10\\nvoid polkrokowe_lewo() {\\n    DDRA=0b11111111;\\n    set_porta_and_wait(0b11111111, 30);\\n    do {\\n        set_porta_and_wait(0b01100000, DELAY);\\n        set_porta_and_wait(0b11100000, DELAY);\\n        set_porta_and_wait(0b11000000, DELAY);\\n        set_porta_and_wait(0b11010000, DELAY);\\n        set_porta_and_wait(0b10010000, DELAY);\\n        set_porta_and_wait(0b10110000, DELAY);\\n        set_porta_and_wait(0b00110000, DELAY);\\n        set_porta_and_wait(0b01110000, DELAY);\\n    } while(1);\\n}\\n```\\n\\n---\\n\\nZbadane oraz zapisane zostały krytyczne wartości opóźnień dla, których praca poszczególnych silników zaczyna być niestabilna.\\n\\n###**Jednofazowy**\\n| Kierunek               | Opóźnienie                            |             Działanie            |\\n ----------------- | ---------------------------- | ------------------\\n| w prawo |  5 ms | Stabilnie |\\n| w prawo        |      4 ms        | Niestabilnie |\\n| w prawo        |      2 ms        | Nie działa |\\n| w lewo |  5 ms | Stabilnie |\\n|  w lewo       |      4 ms        | Niestabilnie |\\n|  w lewo       |      2 ms        | Nie działa |\\n\\n###**Dwufazowy**\\n| Kierunek               | Opóźnienie                            |             Działanie            |\\n ----------------- | ---------------------------- | ------------------\\n| w prawo |  4 ms | Stabilnie |\\n| w prawo        |      3 ms        | Stabilnie |\\n| w prawo        |      2 ms        | Niestabilnie |\\n| w prawo        |      1 ms        | Nie działa |\\n| w lewo |  4 ms | Stabilnie |\\n|  w lewo       |      3 ms        | Niestabilnie |\\n|  w lewo       |      2 ms        | Niestabilnie |\\n|  w lewo       |      1 ms        | Nie działa |\\n\\n\\n###**Półkrokowy**\\n\\n| Kierunek               | Opóźnienie                            |             Działanie            |\\n ----------------- | ---------------------------- | ------------------\\n| w prawo |  2 ms | Stabilnie |\\n| w prawo        |      1 ms        | Nie działa |\\n| w lewo |  2 ms | Stabilnie |\\n|  w lewo       |      1 ms        | Nie działa |\\n\\n\\n--- \\n\\n\\n####**e) Przycisk**:\\n\\nCelem tego ćwiczenia było napisanie kodu obsługującego naciśnięcie przycisku i zaświecenie diody na płytce mikrokontrolera.\\n\\nKod:\\n\\n```c\\n\\nvoid przycisk() {\\n\\tDDRA |= (1<<PA0); // konfiguracja PA0 jako wyjscia\\n\\tPORTA |=(1<<PA0); // wygaszenie LED\\n\\tDDRD &= ~(1<<PD2); // konfiguracja PD2 jako wejscie\\n\\tPORTD |=(1<<PD2); // ustawienie rezystora podciagajacego\\n\\tDDRD &= ~(1<<PD3); \\n\\tPORTD |=(1<<PD3); \\n\\twhile(1) { // nieskonczona petla \\n\\t\\tif ( (PIND & (1<<PD2)) == 0 ) {\\n\\t\\t\\tPORTA=0b00000111; // zapalamy diode sterowana PA0\\n\\t\\t}\\n\\t\\telse if( (PIND & (1<<PD3)) == 0 ) {\\n\\t\\t\\tPORTA &= ~(1<<PA0);\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n####**f) Przycisk - przerwania**:\\n\\nKod realizujący analogiczną funkcje jak poprzedni z tym, że przy wykorzystaniu mechanizmu przerwań:\\n\\n``` \\n#ifndef F_CPU\\n#define F_CPU 16000000 // 16 MHz - turn on external resonator (fuse bits)\\n#endif\\n#include <avr/io.h>\\n#include <avr/interrupt.h>\\nint main(void) {\\n\\tDDRA |= (1<<PA0); //konfiguracja PA0 jako wyjścia\\n\\tPORTA=0x01; // wygaszenie LED\\n\\tDDRD &= ~(1<<PD2); //konfiguracja portu D2 (INT0) jako wejście\\n\\tPORTD |= 1<<PD2; //ustawienie rezystora podciągającego – wymusza 1\\n\\tMCUCR |= 1<<ISC01; //konfiguracja przerwania INT0 – zbocze opadajace\\n\\tGICR |= 1<<INT0; //włączenie przerwania INT0\\n\\tsei(); //globalne włączenie przerwań\\n\\twhile(1) {}\\n}\\n//Procedura obsługi przerwania od wejścia INT0\\nISR(INT0_vect) {\\n\\tPORTA &= ~(1<<PA0); // zapalamy diodę dolaczana do PA0\\n}\\n```\\n\\n---\\n\\n####**g) LCD**:\\n\\nW przypadku ekranu LCD udało nam się napisać kod, którego przez brak czasu nie udało się poprawnie uruchomić, prawdopodobnie przez złe skonfigurowanie przez nas sprzętu lub samej biblioteki do LCD.\\n\\nKod miał wypisywać tekst \\\"żółwik\\\" na ekranie LCD.\\n\\nKod:\\n\\n```c\\nuint8_t zz[] = {0b0010, 0, 0b1111, 0b0001, 0b0110, 0b1000, 0b1111, 0};\\nuint8_t uu[] = {0b0010, 0b0100, 0, 0b0110, 0b1001, 0b1001, 0b0110, 0};\\n\\nint main(void) {\\n\\tchar temp, i;\\n\\tLCD_Initialize();\\n\\tLCD_ProgrammChar(0, zz);\\n\\tLCD_ProgrammChar(1, uu);\\n\\t\\n\\tLCD_GoTo(0,0);\\n\\tLCD_WriteData(0); // “ż”\\n\\tLCD_WriteData(1); // “ó”\\n\\tLCD_WriteText(\\\"lwik\\\"); // “lwik”\\n\\t\\n\\t\\n\\tdo { } while(1);\\n\\t\\n\\treturn 0;\\n}\\n```\\n\\n\\n\",\"title\":\"Sprawozdanie mikro\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","sync.gdrive.0B0eCVEhOzw7BUjVJbmV6bUJJLXM":"{\"id\":\"0B0eCVEhOzw7BUjVJbmV6bUJJLXM\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkyNDExMA\\\"\",\"contentCRC\":\"70afc034\",\"titleCRC\":\"53c2510d\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"\\n### Kurs Deep Learning\\nMail: https://mail.google.com/mail/u/0/#search/craftinity/14c50258a64d212e\\nStrona kursu: ...\\n\\n---- \\n\\n\\n#### Zajęcia 2\\n\\n**Pochodna z funkcji sigoid** $ \\\\sigma $\\nFunkcja **softmax**\\n**Backrop** -> wyprowadzenie\\n\\nGradient Descent -> **Stochastic Gradient Descent**\\n\\nPaper Hinton'a \\n\\n**Homework**: Wyślij rozwiązanie + repo ( są rankingi i punktacje )\\nhttps://mail.google.com/mail/u/0/#search/craftinity/14c50258a64d212e\\n\\n---\\n\\n#### Zajęcia 3\",\"title\":\"Craftinity Deep Learning\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","sync.gdrive.0B0eCVEhOzw7BWmZsNU5XZF9pT3c":"{\"id\":\"0B0eCVEhOzw7BWmZsNU5XZF9pT3c\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkyMjE5Mw\\\"\",\"contentCRC\":\"88f2c99e\",\"titleCRC\":\"c9e5c258\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"\\n## Sysopy\\n\\nStrona prowadzącego:\\n\\n\\nLiteratura:\\n\\n\\n\\n---\",\"title\":\"AGH 4 semestr\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","sync.gdrive.0B0eCVEhOzw7BYXVpazUzN2NrRmM":"{\"id\":\"0B0eCVEhOzw7BYXVpazUzN2NrRmM\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkzMTc2NQ\\\"\",\"contentCRC\":\"74c6f205\",\"titleCRC\":\"b9312dd6\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"**Mikrooperacje**\\n\\nProjekt prostego komputera\\n\\nZainalabedin Navabi Digital Design and Implement....\\n\\nProgram Sequencing Datapath\\n\\nArithmetic-Logical Instructions Data-path\\n\\nDatapath for the Data-Transfer Instructions\\n\\nController Truth Table\\n\\n$$ \\\\int f(x) dx = x $$\",\"title\":\"Mikro wyklad 3 ?\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","sync.gdrive.0B0eCVEhOzw7BaWFfOWVXWkwwM2s":"{\"id\":\"0B0eCVEhOzw7BaWFfOWVXWkwwM2s\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkyOTU0MQ\\\"\",\"contentCRC\":\"39c823b3\",\"titleCRC\":\"8f6b6a44\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"## NodeWebkit\\n\\n**Distribution**\\n\\nhttps://github.com/mllrsohn/grunt-node-webkit-builder\\n> Let's you build your node-webkit apps for osx, win, and linux with grunt. It will download the prebuilt binaries for a specify version, unpacks it, creates a release folder, create the app.nw file for a specified directory and copys the app.nw file where it belongs.\\n\\n\\n`npm install grunt-node-webkit-builder --save-dev`\\n\\n\\n**Gruntfile example for all platforms**\\n```javascript \\ngrunt.initConfig({\\n  nodewebkit: {\\n    options: {\\n        platforms: ['win','osx','linux'],\\n        buildDir: './webkitbuilds', // Where the build version of my node-webkit app is saved\\n    },\\n    src: ['./example/public/**/*'] // Your node-webkit app\\n  },\\n})\\n```\\n\\n#### Full example:\\n\\nhttps://github.com/mllrsohn/grunt-node-webkit-builder/tree/master/example\\n\\n\\nBuild it:\\n```\\nnpm install\\ncd public/ && npm install && cd -\\ngrunt nodewebkit\\n```\\n\\n\\nOutputs ready to fire executables for all platforms\\n\\n**Works on 32/64 bit: Mac/Win/Linux** \",\"title\":\"BVC\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","sync.gdrive.0B0eCVEhOzw7BbDRxZm4xRF8xVmM":"{\"id\":\"0B0eCVEhOzw7BbDRxZm4xRF8xVmM\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkyNTIzNQ\\\"\",\"contentCRC\":\"8e81a7cc\",\"titleCRC\":\"3030056e\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"\\n## Theory / Hardware:\\n\\n\\n## Algorithms:\\n\\n### Multiplication:\\n\\n\\n**SHIFT/ADD sequential** ( works only for multiplicand > 0 )\\n\\n**Booth's algorithm** ( works for negative and positive )\\n\",\"title\":\"Computer's Arithmetic\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","sync.gdrive.0B0eCVEhOzw7BeUdBT0EyRVFsQTA":"{\"id\":\"0B0eCVEhOzw7BeUdBT0EyRVFsQTA\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkyNzM2NQ\\\"\",\"contentCRC\":\"86c76209\",\"titleCRC\":\"2896962a\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"### Czas systemowy:\\n\\n1.Proces macierzysty\\n\\n![enter image description here](http://student.agh.edu.pl/~mfudala/sysopy3_plots/syspar.svg)\\n\\n2.Procesy potomne ( łacznie )\\n\\n![enter image description here](http://student.agh.edu.pl/~mfudala/sysopy3_plots/syschild.svg)\\n\\n\\n3.Sumaryczny czas z 1. i 2.\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/sysparchild.svg)\\n\\nKomentarz:\\nCzas systemowy to czas, poświęcony na samo stworzenie procesu, jak widać `vfork` jest szybszy, ponieważ ma pamięć współdzieloną z procesem macierzystym i nie potrzebuje czasu na początkową kopie pamięci.\\n\\n\\n\\n### Czas użytkownika:\\n\\n1.Proces macierzysty\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/usrpar.svg)\\n\\n2.Procesy potomne ( łacznie )\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/usrchild.svg)\\n\\n3.Sumaryczny czas z 1. i 2.\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/usrparchild.svg)\\n\\n\\nKomentarz:\\nWykres dla samego procesu macierzystego jest bardzo nieregularny co wynika z tego, że ten czas jest bardzo bliski zera, ponieważ proces macierzysty praktycznie nic nie robi w trybie użytkownika.\\nDla procesów potomnych wyraźnie widać przewagę czasową `clone_vfork` oraz `vfork`, wynika to z tego, że procesy tak utworzone w ten sposób mają pamięć współdzieloną z rodzicem i nie tracą czasu na tzw. copy-on-write czyli kopiowanie pamięci z procesu macierzystego dopiero przy próbie jej modyfikacji\\n\\n\\n### Czas sumaryczny użytkownika i systemowy\\n\\n1.Proces macierzysty\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/sysusrpar.svg)\\n\\n2.Procesy potomne ( łacznie )\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/sysusrchild.svg)\\n\\n3.Sumaryczny czas z 1. i 2.\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/sysusrparchild.svg)\\n\\n### Czas rzeczywisty\\n\\n1.Proces macierzysty\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/realpar.svg)\\n\\n2.Procesy potomne ( łacznie )\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/realchild.svg)\\n\\n3.Sumaryczny czas z 1. i 2.\\n\\n![](http://student.agh.edu.pl/~mfudala/sysopy3_plots/realparchild.svg)\\n\\n\\n\\n\",\"title\":\"Sprawko sysop\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","sync.gdrive.0B0eCVEhOzw7BeVRBT2QzX2dIQ3M":"{\"id\":\"0B0eCVEhOzw7BeVRBT2QzX2dIQ3M\",\"etag\":\"\\\"28i-YUCcAhcv4gf_YBu5QxambJ8/MTQyODgzNjkyNjIwMg\\\"\",\"contentCRC\":\"a19c72eb\",\"titleCRC\":\"23833f07\",\"discussionListCRC\":\"a3a6bf43\",\"content\":\"# My notes for Cormen's book ( brainstorm, exercises, solutions )\\n\\n## 22. Graphs\\n\\n### 22.1 Representation of graphs\\n\\n**Exercises:**\\n\\n**22.1-1.**  Out(if computing size of list is $ O(1) $): $ O(V) $ if not $ O (V + E) In: $ O(V + E) $\\n\\n**22.1-2.** Easy. Solved.\\n\\n**22.1-3.** :\\n\\n- Matrix: transpose like in normal matrix. In place, and time complexity $ O(V^2) $\\n- List: create new list, for every $(u,v) \\\\in E$ add u to v entry in list, running time complexity is $ O(V + E) $\\n\\n\\n**22.1-4** For each vertex, add all adjacent vertexes to, a HashSet ( insertion time $O(1)$ ) then make list from this HashSet ( $O(E) $ - ) ( can be better ? ) - and give it to current vertex in newly created list.\\n\\n**22.1-5** su\\n\\n\\n\\n\\n## 25. All-Pairs Shortest Paths\\n\\n\\n\",\"title\":\"Cormen notes\",\"discussionList\":\"{}\",\"provider\":\"gdrive\"}","themeV4":"gray","version":"v23","welcomeTour":"done"}